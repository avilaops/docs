<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avx-shard - Avx Documentation</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="../index.html" style="color: white; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <span>‚ö°</span>
                    <span>Avx Distributed Systems</span>
                </a>
            </div>
            <div class="nav-controls">
                <button class="theme-toggle" onclick="toggleTheme()">‚òÄÔ∏è Modo Claro</button>
                <div class="language-selector">
                    <button class="language-btn" onclick="toggleLanguageDropdown()">üåç Idioma</button>
                    <div class="language-dropdown"></div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div style="margin-bottom: 2rem;">
            <a href="../index.html" style="color: var(--primary-orange);">‚Üê Voltar</a>
        </div>

        <!-- Module Header -->
        <section class="section">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                <span style="font-size: 3rem;">üóÇÔ∏è</span>
                <h1 class="section-title">avx-shard</h1>
            </div>
            <p style="font-size: 1.2rem; opacity: 0.8;">
                Sistema avan√ßado de sharding horizontal para escalabilidade massiva de dados.
            </p>
        </section>

        <!-- Overview -->
        <section class="section">
            <h2 class="section-title">Vis√£o Geral</h2>
            <div class="code-block">
                <p><strong>avx-shard</strong> implementa sharding completo de dados:</p>
                <ul>
                    <li>üóÇÔ∏è <strong>Horizontal Sharding</strong> - Distribui√ß√£o de dados por linhas</li>
                    <li>üéØ <strong>Shard Key Selection</strong> - Escolha autom√°tica de chave de shard</li>
                    <li>üìä <strong>Dynamic Sharding</strong> - Adicionar/remover shards dinamicamente</li>
                    <li>üîÑ <strong>Shard Splitting</strong> - Dividir shards automaticamente</li>
                    <li>‚öñÔ∏è <strong>Load Balancing</strong> - Balanceamento entre shards</li>
                    <li>üîç <strong>Query Routing</strong> - Roteamento inteligente de queries</li>
                    <li>üìà <strong>Auto-Scaling</strong> - Escalar shards baseado em carga</li>
                    <li>üîÄ <strong>Cross-Shard Queries</strong> - Queries agregadas entre shards</li>
                </ul>
            </div>
        </section>

        <!-- Types -->
        <section class="section">
            <h2 class="section-title">Tipos Dispon√≠veis</h2>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>Tipo</th>
                        <th>Descri√ß√£o</th>
                        <th>Uso Principal</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>ShardManager</code></td>
                        <td>Gerenciador de shards</td>
                        <td>Coordena√ß√£o de sharding</td>
                    </tr>
                    <tr>
                        <td><code>Shard</code></td>
                        <td>Representa√ß√£o de shard</td>
                        <td>Parti√ß√£o de dados</td>
                    </tr>
                    <tr>
                        <td><code>ShardKey</code></td>
                        <td>Chave de sharding</td>
                        <td>Campo usado para sharding</td>
                    </tr>
                    <tr>
                        <td><code>ShardRouter</code></td>
                        <td>Roteador de queries</td>
                        <td>Direcionamento de opera√ß√µes</td>
                    </tr>
                    <tr>
                        <td><code>ShardMap</code></td>
                        <td>Mapa de shards</td>
                        <td>Localiza√ß√£o de dados</td>
                    </tr>
                    <tr>
                        <td><code>ShardConfig</code></td>
                        <td>Configura√ß√£o de sharding</td>
                        <td>Par√¢metros e estrat√©gia</td>
                    </tr>
                    <tr>
                        <td><code>ShardMetrics</code></td>
                        <td>M√©tricas de shards</td>
                        <td>Tamanho, carga, performance</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Examples -->
        <section class="section">
            <h2 class="section-title">Exemplos de Uso</h2>
            
            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Configurar Sharding</h3>
            <div class="code-block">
                <pre><code>use avx_shard::{ShardManager, ShardConfig, ShardKey};

let config = ShardConfig {
    shard_count: 16,
    shard_key: ShardKey::field("user_id"),
    auto_split: true,
    rebalance_enabled: true,
};

let mut manager = ShardManager::with_config(config);

// Criar shards
for i in 0..16 {
    manager.create_shard(
        format!("shard_{}", i),
        format!("shard-server-{}.example.com:5432", i)
    )?;
}</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Inserir Dados</h3>
            <div class="code-block">
                <pre><code>use avx_shard::{ShardManager, Record};

let manager = ShardManager::new();

// Inserir registro - shard determinado automaticamente
let record = Record::new()
    .field("user_id", 12345)
    .field("name", "Alice")
    .field("email", "alice@example.com");

// Manager roteia para o shard correto baseado em user_id
manager.insert("users", record)?;

println!("Registro inserido no shard apropriado");</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Query com Shard Key</h3>
            <div class="code-block">
                <pre><code>use avx_shard::{ShardManager, Query};

let manager = ShardManager::new();

// Query com shard key - vai direto para o shard correto
let query = Query::new()
    .table("users")
    .filter("user_id", 12345);

let result = manager.execute(query)?;

// Apenas 1 shard √© consultado (muito eficiente)</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Cross-Shard Query</h3>
            <div class="code-block">
                <pre><code>use avx_shard::{ShardManager, Query};

let manager = ShardManager::new();

// Query SEM shard key - precisa consultar todos os shards
let query = Query::new()
    .table("users")
    .filter("email", "alice@example.com")
    .select(&["user_id", "name"]);

// Manager executa em paralelo em todos os shards
let results = manager.execute_scatter_gather(query)?;

println!("Encontrado em {} shards", results.len());</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Shard Splitting</h3>
            <div class="code-block">
                <pre><code>use avx_shard::ShardManager;

let mut manager = ShardManager::new();

// Monitorar tamanho dos shards
let metrics = manager.get_metrics();

for shard in manager.shards() {
    let size = metrics.shard_size(shard.id());
    
    // Dividir shard se muito grande
    if size > 100_000_000 { // 100GB
        println!("Dividindo shard {}", shard.id());
        
        // Divide em 2 novos shards
        manager.split_shard(shard.id())?;
    }
}

// Rebalancear automaticamente
manager.rebalance()?;</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Query Routing Avan√ßado</h3>
            <div class="code-block">
                <pre><code>use avx_shard::{ShardRouter, Query};

let router = ShardRouter::new(&manager);

let query = Query::new()
    .table("orders")
    .filter("user_id", 12345)
    .filter("status", "pending");

// Analisar query e determinar shards necess√°rios
let routing = router.analyze_query(&query)?;

println!("Query precisa acessar {} shard(s)", routing.shard_count());
println!("Tipo: {:?}", routing.query_type());

// Single shard, multi-shard, ou broadcast</code></pre>
            </div>
        </section>

        <!-- API Reference -->
        <section class="section">
            <h2 class="section-title">Refer√™ncia da API</h2>
            
            <h3 style="color: var(--primary-orange);">ShardManager</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Descri√ß√£o</th>
                        <th>Retorno</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>new()</code></td>
                        <td>Cria manager padr√£o</td>
                        <td><code>ShardManager</code></td>
                    </tr>
                    <tr>
                        <td><code>create_shard(id, addr)</code></td>
                        <td>Cria novo shard</td>
                        <td><code>Result&lt;()&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>insert(table, record)</code></td>
                        <td>Insere registro</td>
                        <td><code>Result&lt;()&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>execute(query)</code></td>
                        <td>Executa query</td>
                        <td><code>Result&lt;ResultSet&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>split_shard(id)</code></td>
                        <td>Divide shard</td>
                        <td><code>Result&lt;()&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>merge_shards(id1, id2)</code></td>
                        <td>Mescla shards</td>
                        <td><code>Result&lt;()&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>rebalance()</code></td>
                        <td>Rebalanceia dados</td>
                        <td><code>Result&lt;()&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>get_metrics()</code></td>
                        <td>Obt√©m m√©tricas</td>
                        <td><code>ShardMetrics</code></td>
                    </tr>
                </tbody>
            </table>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">ShardRouter</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Descri√ß√£o</th>
                        <th>Retorno</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>new(manager)</code></td>
                        <td>Cria router</td>
                        <td><code>ShardRouter</code></td>
                    </tr>
                    <tr>
                        <td><code>route_query(query)</code></td>
                        <td>Determina shards para query</td>
                        <td><code>Vec&lt;ShardId&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>route_insert(record)</code></td>
                        <td>Determina shard para insert</td>
                        <td><code>ShardId</code></td>
                    </tr>
                    <tr>
                        <td><code>analyze_query(query)</code></td>
                        <td>Analisa query</td>
                        <td><code>QueryRouting</code></td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Performance -->
        <section class="section">
            <h2 class="section-title">Performance</h2>
            <div class="animation-showcase">
                <div class="animated-element">
                    üóÇÔ∏è Sharding Massivamente Escal√°vel
                </div>
                <div style="margin-top: 2rem; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto;">
                    <h3 style="color: var(--primary-orange);">Benchmarks</h3>
                    <table class="api-table">
                        <thead>
                            <tr>
                                <th>Opera√ß√£o</th>
                                <th>Tempo</th>
                                <th>Throughput</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Shard Routing</td>
                                <td>~100ns</td>
                                <td>10M routes/s</td>
                            </tr>
                            <tr>
                                <td>Single-Shard Query</td>
                                <td>~5ms</td>
                                <td>200 queries/s</td>
                            </tr>
                            <tr>
                                <td>Cross-Shard Query (16 shards)</td>
                                <td>~20ms</td>
                                <td>50 queries/s</td>
                            </tr>
                            <tr>
                                <td>Shard Split</td>
                                <td>~30s</td>
                                <td>-</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 style="color: var(--primary-orange); margin-top: 2rem;">Otimiza√ß√µes</h3>
                    <ul>
                        <li>‚úÖ Zero-copy routing</li>
                        <li>‚úÖ Parallel shard queries</li>
                        <li>‚úÖ Query result streaming</li>
                        <li>‚úÖ Shard-local caching</li>
                        <li>‚úÖ Background rebalancing</li>
                    </ul>

                    <h3 style="color: var(--primary-orange); margin-top: 2rem;">Escalabilidade</h3>
                    <ul>
                        <li>‚úÖ Escalar horizontalmente at√© milhares de shards</li>
                        <li>‚úÖ Linear scale-out de throughput</li>
                        <li>‚úÖ Petabytes de dados distribu√≠dos</li>
                        <li>‚úÖ Hot-spot mitigation autom√°tica</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Use Cases -->
        <section class="section">
            <h2 class="section-title">Casos de Uso</h2>
            
            <div class="module-card animated-element">
                <h3 class="module-title">üë• Sistema Multi-Tenant</h3>
                <p>Shard por tenant_id para isolamento e escalabilidade.</p>
                <div class="code-block">
                    <pre><code>let config = ShardConfig {
    shard_count: 32,
    shard_key: ShardKey::field("tenant_id"),
    ..Default::default()
};

let manager = ShardManager::with_config(config);

// Cada tenant fica em seu pr√≥prio shard
// Escalabilidade ilimitada de tenants
manager.insert("data", record_with_tenant_id)?;</code></pre>
                </div>
            </div>

            <div class="module-card animated-element" style="margin-top: 2rem;">
                <h3 class="module-title">üìä Time Series Database</h3>
                <p>Shard por range de tempo para queries eficientes.</p>
                <div class="code-block">
                    <pre><code>// Shard por m√™s
let config = ShardConfig {
    shard_key: ShardKey::field("timestamp"),
    strategy: ShardStrategy::Range,
    ..Default::default()
};

// Queries com filtro de data v√£o para poucos shards
let query = Query::new()
    .table("metrics")
    .filter("timestamp", ">", "2025-01-01")
    .filter("timestamp", "<", "2025-01-31");

// Apenas shard de janeiro √© consultado</code></pre>
                </div>
            </div>

            <div class="module-card animated-element" style="margin-top: 2rem;">
                <h3 class="module-title">üéÆ Gaming Leaderboard</h3>
                <p>Shard por regi√£o para baixa lat√™ncia global.</p>
                <div class="code-block">
                    <pre><code>// Shard por regi√£o geogr√°fica
let config = ShardConfig {
    shard_key: ShardKey::field("region"),
    strategy: ShardStrategy::List,
    ..Default::default()
};

// Players na Am√©rica do Norte em shard NA
// Players na Europa em shard EU
// Queries locais s√£o ultra-r√°pidas</code></pre>
                </div>
            </div>
        </section>

        <!-- License -->
        <section class="section">
            <h2 class="section-title">Licen√ßa</h2>
            <div class="code-block">
                <p><strong>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</strong></p>
                <p>Este m√≥dulo faz parte do ecossistema propriet√°rio Avx.</p>
                <p>Para uso comercial, entre em contato:</p>
                <ul>
                    <li>üìß Email: nicolas@avila.inc</li>
                    <li>üåê Website: https://avila.inc</li>
                </ul>
            </div>
        </section>
    </div>

    <footer>
        <p>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</p>
        <p>avx-shard - Software Propriet√°rio</p>
    </footer>

    <script src="../assets/js/main.js"></script>
</body>
</html>