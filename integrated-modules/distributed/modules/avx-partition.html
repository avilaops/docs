<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avx-partition - Avx Documentation</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="../index.html" style="color: white; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <span>‚ö°</span>
                    <span>Avx Distributed Systems</span>
                </a>
            </div>
            <div class="nav-controls">
                <button class="theme-toggle" onclick="toggleTheme()">‚òÄÔ∏è Modo Claro</button>
                <div class="language-selector">
                    <button class="language-btn" onclick="toggleLanguageDropdown()">üåç Idioma</button>
                    <div class="language-dropdown"></div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div style="margin-bottom: 2rem;">
            <a href="../index.html" style="color: var(--primary-orange);">‚Üê Voltar</a>
        </div>

        <!-- Module Header -->
        <section class="section">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                <span style="font-size: 3rem;">üìä</span>
                <h1 class="section-title">avx-partition</h1>
            </div>
            <p style="font-size: 1.2rem; opacity: 0.8;">
                Estrat√©gias avan√ßadas de particionamento de dados para distribui√ß√£o e escalabilidade.
            </p>
        </section>

        <!-- Overview -->
        <section class="section">
            <h2 class="section-title">Vis√£o Geral</h2>
            <div class="code-block">
                <p><strong>avx-partition</strong> implementa estrat√©gias de particionamento de dados:</p>
                <ul>
                    <li>üîë <strong>Hash Partitioning</strong> - Distribui√ß√£o por hash de chave</li>
                    <li>üìè <strong>Range Partitioning</strong> - Particionamento por faixas</li>
                    <li>üìã <strong>List Partitioning</strong> - Particionamento por listas</li>
                    <li>üîÑ <strong>Consistent Hashing</strong> - Minimiza redistribui√ß√£o</li>
                    <li>üéØ <strong>Virtual Nodes</strong> - Balanceamento uniforme</li>
                    <li>‚öñÔ∏è <strong>Load Balancing</strong> - Distribui√ß√£o equilibrada</li>
                    <li>üîÄ <strong>Rebalancing</strong> - Redistribui√ß√£o autom√°tica</li>
                    <li>üìà <strong>Scalability</strong> - Adicionar/remover n√≥s dinamicamente</li>
                </ul>
            </div>
        </section>

        <!-- Types -->
        <section class="section">
            <h2 class="section-title">Tipos Dispon√≠veis</h2>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>Tipo</th>
                        <th>Descri√ß√£o</th>
                        <th>Uso Principal</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>PartitionStrategy</code></td>
                        <td>Estrat√©gia de particionamento</td>
                        <td>Define como particionar</td>
                    </tr>
                    <tr>
                        <td><code>HashPartitioner</code></td>
                        <td>Particionador por hash</td>
                        <td>Distribui√ß√£o uniforme</td>
                    </tr>
                    <tr>
                        <td><code>RangePartitioner</code></td>
                        <td>Particionador por faixa</td>
                        <td>Dados ordenados</td>
                    </tr>
                    <tr>
                        <td><code>ConsistentHashRing</code></td>
                        <td>Anel de hash consistente</td>
                        <td>Minimizar redistribui√ß√£o</td>
                    </tr>
                    <tr>
                        <td><code>Partition</code></td>
                        <td>Representa√ß√£o de parti√ß√£o</td>
                        <td>Unidade de dados</td>
                    </tr>
                    <tr>
                        <td><code>PartitionMap</code></td>
                        <td>Mapa de parti√ß√µes</td>
                        <td>Localiza√ß√£o de dados</td>
                    </tr>
                    <tr>
                        <td><code>RebalanceStrategy</code></td>
                        <td>Estrat√©gia de rebalanceamento</td>
                        <td>Redistribui√ß√£o de dados</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Examples -->
        <section class="section">
            <h2 class="section-title">Exemplos de Uso</h2>
            
            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Hash Partitioning</h3>
            <div class="code-block">
                <pre><code>use avx_partition::{HashPartitioner, PartitionStrategy};

let partitioner = HashPartitioner::new(16); // 16 parti√ß√µes

// Determinar parti√ß√£o para uma chave
let key = "user:12345";
let partition = partitioner.get_partition(key);

println!("Chave '{}' vai para parti√ß√£o {}", key, partition);

// Distribui√ß√£o uniforme garantida
assert!(partition < 16);</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Range Partitioning</h3>
            <div class="code-block">
                <pre><code>use avx_partition::RangePartitioner;

let mut partitioner = RangePartitioner::new();

// Definir faixas
partitioner.add_range(0..1000, "partition_0");
partitioner.add_range(1000..5000, "partition_1");
partitioner.add_range(5000..10000, "partition_2");

// Obter parti√ß√£o por valor
let partition = partitioner.get_partition(&2500);
assert_eq!(partition, "partition_1");

// Ideal para timestamps, IDs sequenciais, etc.</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Consistent Hashing</h3>
            <div class="code-block">
                <pre><code>use avx_partition::ConsistentHashRing;

let mut ring = ConsistentHashRing::new();

// Adicionar n√≥s
ring.add_node("node1", 150); // 150 virtual nodes
ring.add_node("node2", 150);
ring.add_node("node3", 150);

// Obter n√≥ para chave
let node = ring.get_node("user:12345");
println!("Chave vai para: {}", node);

// Adicionar novo n√≥ - apenas ~1/4 dos dados s√£o movidos
ring.add_node("node4", 150);</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Virtual Nodes</h3>
            <div class="code-block">
                <pre><code>use avx_partition::ConsistentHashRing;

let mut ring = ConsistentHashRing::new();

// N√≥s com diferentes capacidades
ring.add_node("node1-high-capacity", 300);  // Mais virtual nodes
ring.add_node("node2-medium", 150);
ring.add_node("node3-low", 75);             // Menos virtual nodes

// Load balancing autom√°tico baseado em virtual nodes
let distribution = ring.get_distribution();
println!("Distribui√ß√£o: {:?}", distribution);</code></pre>
            </div>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">Rebalancing</h3>
            <div class="code-block">
                <pre><code>use avx_partition::{PartitionMap, RebalanceStrategy};

let mut map = PartitionMap::new();

// Estado inicial
map.assign_partition(0, "node1");
map.assign_partition(1, "node1");
map.assign_partition(2, "node2");

// Adicionar novo n√≥
map.add_node("node3");

// Rebalancear automaticamente
let moves = map.rebalance(RebalanceStrategy::MinimizeMoves)?;

println!("Movimentos necess√°rios: {}", moves.len());
for mv in moves {
    println!("Mover parti√ß√£o {} de {} para {}", 
        mv.partition, mv.from, mv.to);
}</code></pre>
            </div>
        </section>

        <!-- API Reference -->
        <section class="section">
            <h2 class="section-title">Refer√™ncia da API</h2>
            
            <h3 style="color: var(--primary-orange);">HashPartitioner</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Descri√ß√£o</th>
                        <th>Retorno</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>new(num_partitions)</code></td>
                        <td>Cria particionador hash</td>
                        <td><code>HashPartitioner</code></td>
                    </tr>
                    <tr>
                        <td><code>get_partition(key)</code></td>
                        <td>Obt√©m parti√ß√£o para chave</td>
                        <td><code>usize</code></td>
                    </tr>
                    <tr>
                        <td><code>num_partitions()</code></td>
                        <td>N√∫mero de parti√ß√µes</td>
                        <td><code>usize</code></td>
                    </tr>
                </tbody>
            </table>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">ConsistentHashRing</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Descri√ß√£o</th>
                        <th>Retorno</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>new()</code></td>
                        <td>Cria hash ring</td>
                        <td><code>ConsistentHashRing</code></td>
                    </tr>
                    <tr>
                        <td><code>add_node(name, vnodes)</code></td>
                        <td>Adiciona n√≥ ao ring</td>
                        <td><code>()</code></td>
                    </tr>
                    <tr>
                        <td><code>remove_node(name)</code></td>
                        <td>Remove n√≥ do ring</td>
                        <td><code>Result&lt;()&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>get_node(key)</code></td>
                        <td>Obt√©m n√≥ para chave</td>
                        <td><code>&str</code></td>
                    </tr>
                    <tr>
                        <td><code>get_nodes(key, n)</code></td>
                        <td>Obt√©m N n√≥s (replica√ß√£o)</td>
                        <td><code>Vec&lt;&str&gt;</code></td>
                    </tr>
                </tbody>
            </table>

            <h3 style="color: var(--primary-orange); margin-top: 2rem;">PartitionMap</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Descri√ß√£o</th>
                        <th>Retorno</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>new()</code></td>
                        <td>Cria mapa de parti√ß√µes</td>
                        <td><code>PartitionMap</code></td>
                    </tr>
                    <tr>
                        <td><code>assign_partition(id, node)</code></td>
                        <td>Atribui parti√ß√£o a n√≥</td>
                        <td><code>()</code></td>
                    </tr>
                    <tr>
                        <td><code>get_node(partition_id)</code></td>
                        <td>Obt√©m n√≥ da parti√ß√£o</td>
                        <td><code>Option&lt;&str&gt;</code></td>
                    </tr>
                    <tr>
                        <td><code>rebalance(strategy)</code></td>
                        <td>Rebalancea parti√ß√µes</td>
                        <td><code>Result&lt;Vec&lt;Move&gt;&gt;</code></td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Performance -->
        <section class="section">
            <h2 class="section-title">Performance</h2>
            <div class="animation-showcase">
                <div class="animated-element">
                    üìä Particionamento Ultra-R√°pido
                </div>
                <div style="margin-top: 2rem; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto;">
                    <h3 style="color: var(--primary-orange);">Benchmarks</h3>
                    <table class="api-table">
                        <thead>
                            <tr>
                                <th>Opera√ß√£o</th>
                                <th>Tempo</th>
                                <th>Throughput</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Hash Partition Lookup</td>
                                <td>~50ns</td>
                                <td>20M lookups/s</td>
                            </tr>
                            <tr>
                                <td>Consistent Hash Lookup</td>
                                <td>~200ns</td>
                                <td>5M lookups/s</td>
                            </tr>
                            <tr>
                                <td>Range Partition Lookup</td>
                                <td>~100ns</td>
                                <td>10M lookups/s</td>
                            </tr>
                            <tr>
                                <td>Add/Remove Node</td>
                                <td>~1ms</td>
                                <td>1000 ops/s</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 style="color: var(--primary-orange); margin-top: 2rem;">Otimiza√ß√µes</h3>
                    <ul>
                        <li>‚úÖ Zero-allocation lookups</li>
                        <li>‚úÖ Binary search para ranges</li>
                        <li>‚úÖ Optimized hash functions</li>
                        <li>‚úÖ Cache-friendly data structures</li>
                        <li>‚úÖ Lock-free reads</li>
                    </ul>

                    <h3 style="color: var(--primary-orange); margin-top: 2rem;">Garantias</h3>
                    <ul>
                        <li>‚úÖ Distribui√ß√£o uniforme (hash)</li>
                        <li>‚úÖ M√≠nima redistribui√ß√£o (consistent hash)</li>
                        <li>‚úÖ O(1) lookups para hash</li>
                        <li>‚úÖ O(log n) lookups para range</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Use Cases -->
        <section class="section">
            <h2 class="section-title">Casos de Uso</h2>
            
            <div class="module-card animated-element">
                <h3 class="module-title">üíæ Banco de Dados Distribu√≠do</h3>
                <p>Particione dados entre m√∫ltiplos servidores de banco de dados.</p>
                <div class="code-block">
                    <pre><code>let partitioner = HashPartitioner::new(16);

// Determinar servidor para cada usu√°rio
let user_id = "user:12345";
let partition = partitioner.get_partition(user_id);
let server = format!("db-server-{}", partition % 4);

println!("Usu√°rio {} -> Servidor {}", user_id, server);

// Distribui√ß√£o uniforme garante load balancing</code></pre>
                </div>
            </div>

            <div class="module-card animated-element" style="margin-top: 2rem;">
                <h3 class="module-title">üîÑ Cache Distribu√≠do</h3>
                <p>Use consistent hashing para cache resiliente.</p>
                <div class="code-block">
                    <pre><code>let mut ring = ConsistentHashRing::new();
ring.add_node("cache1", 150);
ring.add_node("cache2", 150);
ring.add_node("cache3", 150);

// Obter servidor de cache
let key = "session:abc123";
let cache_server = ring.get_node(key);

// Adicionar novo servidor - apenas 25% dos dados movem
ring.add_node("cache4", 150);</code></pre>
                </div>
            </div>

            <div class="module-card animated-element" style="margin-top: 2rem;">
                <h3 class="module-title">üìà Time Series Data</h3>
                <p>Particione dados temporais por faixas de tempo.</p>
                <div class="code-block">
                    <pre><code>let mut partitioner = RangePartitioner::new();

// Particionar por m√™s
partitioner.add_range(202501..202502, "jan-2025");
partitioner.add_range(202502..202503, "feb-2025");
partitioner.add_range(202503..202504, "mar-2025");

// Query autom√°tica para parti√ß√£o correta
let timestamp = 20250215; // 15 de fevereiro
let partition = partitioner.get_partition(&timestamp);
// Retorna "feb-2025"</code></pre>
                </div>
            </div>
        </section>

        <!-- License -->
        <section class="section">
            <h2 class="section-title">Licen√ßa</h2>
            <div class="code-block">
                <p><strong>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</strong></p>
                <p>Este m√≥dulo faz parte do ecossistema propriet√°rio Avx.</p>
                <p>Para uso comercial, entre em contato:</p>
                <ul>
                    <li>üìß Email: nicolas@avila.inc</li>
                    <li>üåê Website: https://avila.inc</li>
                </ul>
            </div>
        </section>
    </div>

    <footer>
        <p>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</p>
        <p>avx-partition - Software Propriet√°rio</p>
    </footer>

    <script src="../assets/js/main.js"></script>
</body>
</html>