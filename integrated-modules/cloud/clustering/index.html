<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avx Clustering - Documentation</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body class="light-theme">
    <nav class="navbar">
        <div class="navbar-content">
            <a href="https://docs.avila.inc/" class="logo">
                <span>üöÄ</span>
                <span>Avx</span>
            </a>
            <div class="controls">
                <select id="lang-selector" class="lang-selector">
                    <option value="pt-BR">üáßüá∑ Portugu√™s</option>
                    <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
                    <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                    <option value="zh-TW">üáπüáº ÁπÅÈ´î‰∏≠Êñá</option>
                    <option value="ur">üáµüá∞ ÿßÿ±ÿØŸà</option>
                    <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                    <option value="de">üá©üá™ Deutsch</option>
                    <option value="lv">üá±üáª Latvie≈°u</option>
                    <option value="uz">üá∫üáø O'zbek</option>
                    <option value="es">üá™üá∏ Espa√±ol</option>
                </select>
                <button id="theme-toggle" class="theme-toggle">üåô Escuro</button>
            </div>
        </div>
    </nav>

    <div class="main-content">
        <div class="breadcrumb">
            <a href="../index.html">Home</a> / <strong>Clustering</strong>
        </div>

        <section class="hero">
            <h1>üî¨ Avx Clustering</h1>
            <p>Algoritmos de clustering de √∫ltima gera√ß√£o para an√°lise de dados e aprendizado de m√°quina</p>
        </section>

        <!-- Overview -->
        <section class="section">
            <h2 data-i18n="section.overview">Vis√£o Geral do M√≥dulo</h2>
            <div class="card">
                <p><strong>avx-clustering</strong> √© uma biblioteca completa de algoritmos de clustering implementada em Rust, projetada para superar bibliotecas existentes em performance e funcionalidade. Oferece implementa√ß√µes otimizadas de mais de 15 algoritmos diferentes.</p>
                
                <h3>üéØ Principais Benef√≠cios</h3>
                <ul>
                    <li><strong>Performance Superior:</strong> At√© 10x mais r√°pido que implementa√ß√µes tradicionais</li>
                    <li><strong>Algoritmos Avan√ßados:</strong> HDBSCAN, OPTICS, Spectral e mais</li>
                    <li><strong>Suporte GPU:</strong> Acelera√ß√£o CUDA para grandes datasets</li>
                    <li><strong>Cientificamente Preciso:</strong> Implementa√ß√µes baseadas em papers</li>
                    <li><strong>F√°cil de Usar:</strong> API fluente e intuitiva</li>
                    <li><strong>Visualiza√ß√£o Integrada:</strong> Exports para m√∫ltiplos formatos</li>
                </ul>

                <h3>üì¶ Instala√ß√£o</h3>
                <pre><code>[dependencies]
avx-clustering = "0.1.1"

# Com suporte GPU
[dependencies]
avx-clustering = { version = "0.1.1", features = ["gpu"] }</code></pre>
            </div>
        </section>

        <!-- Algorithm Categories -->
        <section class="section">
            <h2>üß¨ Categorias de Algoritmos</h2>
            
            <div class="cards-grid">
                <div class="card">
                    <h3>üìç Particionais</h3>
                    <p><strong>KMeans, KMedoids, Fuzzy C-Means, Mean Shift</strong></p>
                    <p>Algoritmos que dividem dados em k parti√ß√µes baseadas em centr√≥ides ou med√≥ides.</p>
                </div>

                <div class="card">
                    <h3>üåä Baseados em Densidade</h3>
                    <p><strong>DBSCAN, HDBSCAN, OPTICS, DENCLUE</strong></p>
                    <p>Identificam clusters como regi√µes de alta densidade separadas por regi√µes de baixa densidade.</p>
                </div>

                <div class="card">
                    <h3>üå≥ Hier√°rquicos</h3>
                    <p><strong>Agglomerative, Divisive, BIRCH</strong></p>
                    <p>Constroem hierarquias de clusters atrav√©s de fus√£o ou divis√£o sucessiva.</p>
                </div>

                <div class="card">
                    <h3>üìä Baseados em Modelo</h3>
                    <p><strong>GMM, Bayesian GMM, Dirichlet Process</strong></p>
                    <p>Modelam dados como misturas de distribui√ß√µes probabil√≠sticas.</p>
                </div>

                <div class="card">
                    <h3>üï∏Ô∏è Baseados em Grafo</h3>
                    <p><strong>Spectral, Louvain, Leiden, Affinity Propagation</strong></p>
                    <p>Utilizam teoria de grafos para identificar comunidades e estruturas.</p>
                </div>

                <div class="card">
                    <h3>üî¨ Cient√≠ficos</h3>
                    <p><strong>4D Clustering, Curved Manifolds, Streaming</strong></p>
                    <p>Algoritmos especializados para dados espa√ßo-temporais e variedades curvas.</p>
                </div>
            </div>
        </section>

        <!-- Types -->
        <section class="section">
            <h2 data-i18n="section.types">Tipos e Algoritmos Dispon√≠veis</h2>

            <div class="card">
                <h3>KMeans</h3>
                <p>Clustering particional cl√°ssico com m√∫ltiplos m√©todos de inicializa√ß√£o.</p>
                <pre><code>pub struct KMeansBuilder {
    n_clusters: usize,
    init_method: InitMethod,
    algorithm: Algorithm,
    max_iter: usize,
    tolerance: f64,
    n_init: usize,
    random_state: Option&lt;u64&gt;,
    parallel: bool,
    gpu: bool,
}

pub enum InitMethod {
    Random,
    KMeansPlusPlus,
    Forgy,
}

pub enum Algorithm {
    Lloyd,
    Elkan,
    MiniBatch { batch_size: usize },
}</code></pre>
            </div>

            <div class="card">
                <h3>DBSCAN</h3>
                <p>Clustering baseado em densidade que identifica outliers automaticamente.</p>
                <pre><code>pub struct DBSCAN {
    eps: f64,
    min_samples: usize,
    metric: Metric,
}

impl DBSCAN {
    pub fn new(eps: f64, min_samples: usize) -> Self;
    pub fn metric(self, metric: Metric) -> Self;
    pub fn fit(&self, data: &ArrayView2&lt;f64&gt;) -> Result&lt;DBSCANResult&gt;;
}</code></pre>
            </div>

            <div class="card">
                <h3>HDBSCAN</h3>
                <p>Vers√£o hier√°rquica do DBSCAN com detec√ß√£o autom√°tica de par√¢metros.</p>
                <pre><code>pub struct HDBSCAN {
    min_cluster_size: usize,
    min_samples: Option&lt;usize&gt;,
    metric: Metric,
    alpha: f64,
    cluster_selection_method: ClusterSelectionMethod,
}

pub enum ClusterSelectionMethod {
    EOM,
    Leaf,
}</code></pre>
            </div>

            <div class="card">
                <h3>Spectral Clustering</h3>
                <p>Utiliza teoria espectral de grafos para clustering.</p>
                <pre><code>pub struct SpectralClustering {
    n_clusters: usize,
    affinity: AffinityType,
    n_neighbors: usize,
    gamma: f64,
    eigen_solver: Option&lt;EigenSolver&gt;,
}

pub enum AffinityType {
    Rbf,
    Nearest,
    Precomputed,
}</code></pre>
            </div>

            <div class="card">
                <h3>Gaussian Mixture Model (GMM)</h3>
                <p>Modelagem probabil√≠stica com misturas de gaussianas.</p>
                <pre><code>pub struct GMM {
    n_components: usize,
    covariance_type: CovarianceType,
    max_iter: usize,
    n_init: usize,
    init_params: InitParams,
    reg_covar: f64,
}

pub enum CovarianceType {
    Full,
    Tied,
    Diagonal,
    Spherical,
}</code></pre>
            </div>

            <div class="card">
                <h3>Hierarchical Clustering</h3>
                <p>Clustering hier√°rquico aglomerativo e divisivo.</p>
                <pre><code>pub struct HierarchicalClustering {
    n_clusters: usize,
    linkage: LinkageType,
    metric: Metric,
    compute_full_tree: bool,
}

pub enum LinkageType {
    Ward,
    Complete,
    Average,
    Single,
}</code></pre>
            </div>

            <div class="card">
                <h3>M√©tricas de Dist√¢ncia</h3>
                <pre><code>pub enum Metric {
    Euclidean,
    Manhattan,
    Cosine,
    Chebyshev,
    Minkowski { p: f64 },
    Haversine,
    Mahalanobis,
}</code></pre>
            </div>

            <div class="card">
                <h3>M√©tricas de Valida√ß√£o</h3>
                <pre><code>pub fn silhouette_score(data: &Array2&lt;f64&gt;, labels: &Array1&lt;i32&gt;) -> f64;
pub fn davies_bouldin_score(data: &Array2&lt;f64&gt;, labels: &Array1&lt;i32&gt;) -> f64;
pub fn calinski_harabasz_score(data: &Array2&lt;f64&gt;, labels: &Array1&lt;i32&gt;) -> f64;
pub fn adjusted_rand_index(labels_true: &Array1&lt;i32&gt;, labels_pred: &Array1&lt;i32&gt;) -> f64;</code></pre>
            </div>
        </section>

        <!-- Examples -->
        <section class="section">
            <h2 data-i18n="section.examples">Exemplos de Uso</h2>

            <div class="card">
                <h3>Exemplo 1: KMeans B√°sico</h3>
                <pre><code>use avx_clustering::prelude::*;
use ndarray::Array2;

fn main() -> Result&lt;()&gt; {
    // Gerar dados de exemplo
    let data = Array2::from_shape_vec((150, 2), vec![
        // ... seus dados aqui
    ])?;
    
    // Configurar e executar KMeans
    let kmeans = KMeansBuilder::new(3)
        .init_method(InitMethod::KMeansPlusPlus)
        .max_iter(300)
        .tolerance(1e-4)
        .parallel(true)
        .build();
    
    let result = kmeans.fit(&data.view())?;
    
    println!("Labels: {:?}", result.labels);
    println!("Centroids: {:?}", result.centroids);
    println!("Inertia: {}", result.inertia);
    println!("Iterations: {}", result.n_iter);
    
    Ok(())
}</code></pre>
            </div>

            <div class="card">
                <h3>Exemplo 2: DBSCAN com Outlier Detection</h3>
                <pre><code>use avx_clustering::prelude::*;

fn main() -> Result&lt;()&gt; {
    let data = load_dataset("iris.csv")?;
    
    // DBSCAN detecta outliers automaticamente
    let dbscan = DBSCAN::new(0.5, 5)
        .metric(Metric::Euclidean);
    
    let result = dbscan.fit(&data.view())?;
    
    // Labels -1 s√£o outliers
    let outliers: Vec&lt;usize&gt; = result.labels
        .iter()
        .enumerate()
        .filter(|(_, &label)| label == -1)
        .map(|(idx, _)| idx)
        .collect();
    
    println!("Encontrados {} outliers", outliers.len());
    println!("N√∫mero de clusters: {}", result.n_clusters);
    
    Ok(())
}</code></pre>
            </div>

            <div class="card">
                <h3>Exemplo 3: HDBSCAN para Datasets Complexos</h3>
                <pre><code>use avx_clustering::prelude::*;

fn main() -> Result&lt;()&gt; {
    let data = load_complex_dataset()?;
    
    // HDBSCAN funciona bem com clusters de densidade vari√°vel
    let hdbscan = HDBSCANBuilder::new()
        .min_cluster_size(10)
        .min_samples(5)
        .metric(Metric::Euclidean)
        .cluster_selection_method(ClusterSelectionMethod::EOM)
        .build();
    
    let result = hdbscan.fit(&data.view())?;
    
    // Obter probabilidades de pertencimento
    for (i, &prob) in result.probabilities.iter().enumerate() {
        println!("Amostra {}: cluster {} (prob: {:.2})", 
            i, result.labels[i], prob);
    }
    
    Ok(())
}</code></pre>
            </div>

            <div class="card">
                <h3>Exemplo 4: Spectral Clustering para Grafos</h3>
                <pre><code>use avx_clustering::prelude::*;

fn main() -> Result&lt;()&gt; {
    let data = load_graph_data()?;
    
    // Spectral Clustering para dados com estrutura n√£o-convexa
    let spectral = SpectralClusteringBuilder::new(5)
        .affinity(AffinityType::Rbf)
        .gamma(1.0)
        .n_neighbors(10)
        .build();
    
    let result = spectral.fit(&data.view())?;
    
    println!("Clusters identificados: {}", result.n_clusters);
    
    Ok(())
}</code></pre>
            </div>

            <div class="card">
                <h3>Exemplo 5: GMM com Sele√ß√£o Autom√°tica de Componentes</h3>
                <pre><code>use avx_clustering::prelude::*;

fn main() -> Result&lt;()&gt; {
    let data = load_dataset("wine.csv")?;
    
    // GMM para clustering probabil√≠stico
    let gmm = GMMBuilder::new(3)
        .covariance_type(CovarianceType::Full)
        .max_iter(100)
        .n_init(10)
        .build();
    
    let result = gmm.fit(&data.view())?;
    
    // Obter probabilidades de classe
    let probabilities = gmm.predict_proba(&data.view())?;
    
    println!("BIC: {}", result.bic);
    println!("AIC: {}", result.aic);
    
    Ok(())
}</code></pre>
            </div>

            <div class="card">
                <h3>Exemplo 6: Visualiza√ß√£o e Export</h3>
                <pre><code>use avx_clustering::prelude::*;
use avx_clustering::visualization::*;

fn main() -> Result&lt;()&gt; {
    let data = load_dataset("iris.csv")?;
    let kmeans = KMeans::new(3);
    let result = kmeans.fit(&data.view())?;
    
    // Proje√ß√£o para visualiza√ß√£o 2D
    let projection_engine = ProjectionEngine::new();
    let projected = projection_engine.project(
        &data.view(),
        ProjectionType::TSNE { perplexity: 30.0 }
    )?;
    
    // Export para SVG
    let export_engine = ExportEngine::new();
    export_engine.to_svg(
        &projected,
        &result.labels,
        "clusters.svg"
    )?;
    
    // Export para JSON
    export_engine.to_json(
        &result,
        "clusters.json"
    )?;
    
    Ok(())
}</code></pre>
            </div>

            <div class="card">
                <h3>Exemplo 7: Pipeline Completo com Valida√ß√£o</h3>
                <pre><code>use avx_clustering::prelude::*;
use avx_clustering::metrics::validation::*;

fn main() -> Result&lt;()&gt; {
    let data = load_dataset("customer_data.csv")?;
    
    // Preprocessing
    let normalized = normalize(&data)?;
    
    // Feature selection
    let selected = select_features(&normalized, 10)?;
    
    // Encontrar n√∫mero √≥timo de clusters
    let mut best_score = f64::NEG_INFINITY;
    let mut best_k = 2;
    
    for k in 2..=10 {
        let kmeans = KMeans::new(k);
        let result = kmeans.fit(&selected.view())?;
        let score = silhouette_score(&selected, &result.labels);
        
        if score > best_score {
            best_score = score;
            best_k = k;
        }
    }
    
    println!("Melhor n√∫mero de clusters: {}", best_k);
    println!("Silhouette score: {:.3}", best_score);
    
    // Clustering final
    let final_kmeans = KMeans::new(best_k);
    let final_result = final_kmeans.fit(&selected.view())?;
    
    // Valida√ß√£o
    let db_score = davies_bouldin_score(&selected, &final_result.labels);
    let ch_score = calinski_harabasz_score(&selected, &final_result.labels);
    
    println!("Davies-Bouldin: {:.3}", db_score);
    println!("Calinski-Harabasz: {:.3}", ch_score);
    
    Ok(())
}</code></pre>
            </div>
        </section>

        <!-- API Reference -->
        <section class="section">
            <h2 data-i18n="section.api">Refer√™ncia da API</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>Algoritmo</th>
                        <th>Complexidade</th>
                        <th>Casos de Uso</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>KMeans</td>
                        <td>O(n¬∑k¬∑i¬∑d)</td>
                        <td>Clusters esf√©ricos, grande escala</td>
                    </tr>
                    <tr>
                        <td>DBSCAN</td>
                        <td>O(n log n)</td>
                        <td>Formas arbitr√°rias, outliers</td>
                    </tr>
                    <tr>
                        <td>HDBSCAN</td>
                        <td>O(n log n)</td>
                        <td>Densidade vari√°vel, hierarquia</td>
                    </tr>
                    <tr>
                        <td>Spectral</td>
                        <td>O(n¬≥)</td>
                        <td>Grafos, formas complexas</td>
                    </tr>
                    <tr>
                        <td>GMM</td>
                        <td>O(n¬∑k¬∑d¬≤¬∑i)</td>
                        <td>Probabil√≠stico, soft clustering</td>
                    </tr>
                    <tr>
                        <td>Hierarchical</td>
                        <td>O(n¬≤log n)</td>
                        <td>Dendrogramas, taxonomias</td>
                    </tr>
                    <tr>
                        <td>Mean Shift</td>
                        <td>O(n¬≤)</td>
                        <td>Encontrar modas, vis√£o computacional</td>
                    </tr>
                    <tr>
                        <td>OPTICS</td>
                        <td>O(n log n)</td>
                        <td>An√°lise de densidade, visualiza√ß√£o</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Performance -->
        <section class="section">
            <h2 data-i18n="section.performance">Performance</h2>
            
            <div class="performance-chart">
                <h3>Benchmarks vs. Bibliotecas Populares (1M amostras)</h3>
                
                <div class="chart-bar">
                    <span class="chart-label">Avx KMeans</span>
                    <div class="chart-value" style="width: 95%;"></div>
                    <span class="chart-number">2.3s</span>
                </div>
                
                <div class="chart-bar">
                    <span class="chart-label">Avx DBSCAN</span>
                    <div class="chart-value" style="width: 90%;"></div>
                    <span class="chart-number">4.1s</span>
                </div>
                
                <div class="chart-bar">
                    <span class="chart-label">Avx HDBSCAN</span>
                    <div class="chart-value" style="width: 85%;"></div>
                    <span class="chart-number">5.8s</span>
                </div>
                
                <div class="chart-bar">
                    <span class="chart-label">Avx Spectral</span>
                    <div class="chart-value" style="width: 70%;"></div>
                    <span class="chart-number">12.5s</span>
                </div>
                
                <div class="chart-bar">
                    <span class="chart-label">Avx GMM</span>
                    <div class="chart-value" style="width: 80%;"></div>
                    <span class="chart-number">7.2s</span>
                </div>
            </div>

            <div class="card">
                <h3>üöÄ Otimiza√ß√µes Implementadas</h3>
                <ul>
                    <li><strong>Paraleliza√ß√£o Autom√°tica:</strong> Uso de Rayon para opera√ß√µes paralelas</li>
                    <li><strong>Acelera√ß√£o GPU:</strong> Kernels CUDA para algoritmos selecionados</li>
                    <li><strong>Estruturas de Dados Eficientes:</strong> KD-trees para range queries</li>
                    <li><strong>SIMD:</strong> Instru√ß√µes vetoriais para c√°lculos de dist√¢ncia</li>
                    <li><strong>Cache-Friendly:</strong> Layout de mem√≥ria otimizado</li>
                    <li><strong>Lazy Evaluation:</strong> Computa√ß√£o sob demanda</li>
                    <li><strong>Algoritmos Aproximados:</strong> Trade-off precis√£o/velocidade</li>
                </ul>
            </div>

            <div class="card">
                <h3>üìä Compara√ß√£o de Mem√≥ria</h3>
                <p>Uso de mem√≥ria para 1M amostras, 100 features:</p>
                <ul>
                    <li><strong>KMeans:</strong> ~800 MB</li>
                    <li><strong>DBSCAN:</strong> ~1.2 GB</li>
                    <li><strong>HDBSCAN:</strong> ~1.5 GB</li>
                    <li><strong>Spectral:</strong> ~8 GB (matriz de afinidade)</li>
                    <li><strong>GMM:</strong> ~2 GB (covari√¢ncias)</li>
                </ul>
            </div>
        </section>

        <!-- Use Cases -->
        <section class="section">
            <h2 data-i18n="section.useCases">Casos de Uso com Anima√ß√µes</h2>

            <div id="cluster-animation" class="animation-container"></div>

            <div class="cards-grid">
                <div class="card">
                    <h3>üë• Segmenta√ß√£o de Clientes</h3>
                    <p>Identifique grupos de clientes com comportamentos similares para marketing direcionado.</p>
                    <ul>
                        <li>Algoritmos: KMeans, GMM, Hierarchical</li>
                        <li>Features: compras, demografia, comportamento</li>
                        <li>M√©tricas: Silhouette, Davies-Bouldin</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üîç Detec√ß√£o de Anomalias</h3>
                    <p>Encontre outliers e comportamentos an√¥malos em dados de log ou transa√ß√µes.</p>
                    <ul>
                        <li>Algoritmos: DBSCAN, HDBSCAN, Isolation Forest</li>
                        <li>Features: m√©tricas de sistema, padr√µes de acesso</li>
                        <li>Aplica√ß√µes: seguran√ßa, fraude, monitoramento</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üñºÔ∏è Segmenta√ß√£o de Imagens</h3>
                    <p>Divida imagens em regi√µes semanticamente significativas.</p>
                    <ul>
                        <li>Algoritmos: Mean Shift, Spectral, Graph-based</li>
                        <li>Features: cor, textura, gradientes</li>
                        <li>Aplica√ß√µes: vis√£o computacional, edi√ß√£o</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üß¨ Bioinform√°tica</h3>
                    <p>Agrupe genes, prote√≠nas ou sequ√™ncias com perfis de express√£o similares.</p>
                    <ul>
                        <li>Algoritmos: Hierarchical, Fuzzy C-Means</li>
                        <li>Features: express√£o g√™nica, sequ√™ncias</li>
                        <li>Visualiza√ß√£o: heatmaps, dendrogramas</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üåê An√°lise de Redes Sociais</h3>
                    <p>Detecte comunidades e influenciadores em grafos sociais.</p>
                    <ul>
                        <li>Algoritmos: Louvain, Leiden, Spectral</li>
                        <li>Features: conex√µes, intera√ß√µes, metadados</li>
                        <li>M√©tricas: modularidade, centralidade</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üìà An√°lise de S√©ries Temporais</h3>
                    <p>Agrupe s√©ries temporais com padr√µes similares.</p>
                    <ul>
                        <li>Algoritmos: DTW KMeans, Shape-based</li>
                        <li>Features: correla√ß√£o, autocorrela√ß√£o, trends</li>
                        <li>Aplica√ß√µes: finan√ßas, IoT, clima</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üó∫Ô∏è An√°lise Geoespacial</h3>
                    <p>Identifique padr√µes espaciais em dados de localiza√ß√£o.</p>
                    <ul>
                        <li>Algoritmos: DBSCAN (Haversine), HDBSCAN</li>
                        <li>Features: latitude, longitude, atributos</li>
                        <li>Aplica√ß√µes: urbanismo, log√≠stica</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üìù An√°lise de Documentos</h3>
                    <p>Agrupe documentos por t√≥picos e conte√∫do sem√¢ntico.</p>
                    <ul>
                        <li>Algoritmos: Spectral, Hierarchical, LDA</li>
                        <li>Features: TF-IDF, embeddings, topics</li>
                        <li>Aplica√ß√µes: pesquisa, recomenda√ß√£o</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>üè≠ Manuten√ß√£o Preditiva</h3>
                    <p>Identifique padr√µes de falha em equipamentos industriais.</p>
                    <ul>
                        <li>Algoritmos: HDBSCAN, GMM, Streaming</li>
                        <li>Features: sensores, vibra√ß√£o, temperatura</li>
                        <li>Aplica√ß√µes: ind√∫stria 4.0, IoT</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Advanced Features -->
        <section class="section">
            <h2>üî¨ Recursos Avan√ßados</h2>

            <div class="cards-grid">
                <div class="card">
                    <h3>üåÄ Clustering em Variedades Curvas</h3>
                    <p>Suporte para dados em espa√ßos n√£o-euclidianos como esferas e hiperb√≥licos.</p>
                </div>

                <div class="card">
                    <h3>‚è±Ô∏è Clustering Espa√ßo-Temporal</h3>
                    <p>Algoritmos especializados para dados 4D (x, y, z, t).</p>
                </div>

                <div class="card">
                    <h3>üîÑ Streaming Clustering</h3>
                    <p>Processamento de dados em tempo real com atualiza√ß√£o incremental.</p>
                </div>

                <div class="card">
                    <h3>üéØ Auto-Tuning</h3>
                    <p>Sele√ß√£o autom√°tica de hiperpar√¢metros via grid search e Bayesian optimization.</p>
                </div>

                <div class="card">
                    <h3>üé® Visualiza√ß√£o Integrada</h3>
                    <p>Proje√ß√µes 2D/3D com t-SNE, UMAP, PCA e exports para SVG, PNG, JSON.</p>
                </div>

                <div class="card">
                    <h3>üì¶ Serializa√ß√£o</h3>
                    <p>Salve e carregue modelos treinados para deploy em produ√ß√£o.</p>
                </div>
            </div>
        </section>

        <!-- License -->
        <section class="section">
            <h2 data-i18n="section.license">Licen√ßa</h2>
            <div class="card">
                <h3>üîí Software Propriet√°rio</h3>
                <p>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</p>
                <p>Este software √© propriedade exclusiva da Avx. O uso comercial requer licen√ßa.</p>
                <br>
                <p><strong>Contato para Licenciamento:</strong></p>
                <ul>
                    <li>üìß Email: nicolas@avila.inc</li>
                    <li>üåê Website: <a href="https://avila.inc">avila.inc</a></li>
                </ul>
            </div>
        </section>
    </div>

    <footer>
        <p data-i18n="footer.copyright">¬© 2025 Avx - Todos os direitos reservados</p>
        <p data-i18n="footer.proprietary">Software Propriet√°rio</p>
    </footer>

    <script src="../assets/js/i18n.js"></script>
    <script src="../assets/js/main.js"></script>
</body>
</html>
