<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AVX gRPC - Framework gRPC de alta performance">
    <title>AVX gRPC - Documenta√ß√£o</title>
    <link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo"><a href="../index.html" style="text-decoration:none;color:inherit;">AVX Network</a></div>
                <div class="controls">
                    <button id="theme-toggle" class="theme-toggle">üåô</button>
                    <select id="lang-select" class="lang-select">
                        <option value="pt-BR">üáßüá∑ Portugu√™s</option>
                        <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
                        <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                        <option value="zh-TW">üáπüáº ÁπÅÈ´î‰∏≠Êñá</option>
                        <option value="ur">üáµüá∞ ÿßÿ±ÿØŸà</option>
                        <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                        <option value="de">üá©üá™ Deutsch</option>
                        <option value="lv">üá±üáª Latvie≈°u</option>
                        <option value="uz">üá∫üáø O'zbek</option>
                        <option value="es">üá™üá∏ Espa√±ol</option>
                    </select>
                </div>
            </div>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul class="nav-links">
                <li><a href="#overview">Vis√£o Geral</a></li>
                <li><a href="#types">Tipos Dispon√≠veis</a></li>
                <li><a href="#examples">Exemplos</a></li>
                <li><a href="#api">API</a></li>
                <li><a href="#performance">Performance</a></li>
                <li><a href="#usecases">Casos de Uso</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <div class="container">
            <div class="hero">
                <h1>üîå AVX gRPC</h1>
                <p>Framework gRPC nativo de alta performance para comunica√ß√£o entre microservi√ßos</p>
            </div>

            <section id="overview" class="section fade-in">
                <h2>üìã Vis√£o Geral</h2>
                <p>AVX gRPC √© uma implementa√ß√£o completa do protocolo gRPC, constru√≠da do zero sem depend√™ncias externas. Oferece comunica√ß√£o eficiente entre microservi√ßos com suporte a streaming bidirecional, multiplexing HTTP/2, e codifica√ß√£o Protocol Buffers otimizada.</p>

                <div class="modules-grid mt-3">
                    <div class="module-card">
                        <h3>‚ö° Ultra Performance</h3>
                        <p>80.000+ RPC/s com lat√™ncia p99 < 2ms e zero-copy streaming</p>
                    </div>
                    <div class="module-card">
                        <h3>üîí Type-Safe</h3>
                        <p>Protocol Buffers com valida√ß√£o em tempo de compila√ß√£o</p>
                    </div>
                    <div class="module-card">
                        <h3>üéØ Streaming</h3>
                        <p>Unary, server stream, client stream e bidirectional streaming</p>
                    </div>
                    <div class="module-card">
                        <h3>üöÄ HTTP/2</h3>
                        <p>Multiplexing eficiente, header compression e flow control</p>
                    </div>
                </div>
            </section>

            <section id="types" class="section fade-in">
                <h2>üì¶ Tipos Dispon√≠veis</h2>

                <h3>Core</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>GrpcServer</code></td>
                            <td>Servidor gRPC com multiplexing HTTP/2</td>
                        </tr>
                        <tr>
                            <td><code>GrpcClient</code></td>
                            <td>Cliente gRPC com connection pooling</td>
                        </tr>
                        <tr>
                            <td><code>ServiceDefinition</code></td>
                            <td>Defini√ß√£o de servi√ßo com m√©todos RPC</td>
                        </tr>
                        <tr>
                            <td><code>Method</code></td>
                            <td>M√©todo RPC (unary, streaming, etc)</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Request/Response</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Request&lt;T&gt;</code></td>
                            <td>Requisi√ß√£o gRPC com metadata e payload</td>
                        </tr>
                        <tr>
                            <td><code>Response&lt;T&gt;</code></td>
                            <td>Resposta gRPC com status e payload</td>
                        </tr>
                        <tr>
                            <td><code>Metadata</code></td>
                            <td>Headers e metadados da requisi√ß√£o</td>
                        </tr>
                        <tr>
                            <td><code>Status</code></td>
                            <td>Status code gRPC (OK, NOT_FOUND, etc)</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Streaming</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ServerStream&lt;T&gt;</code></td>
                            <td>Stream do servidor para cliente</td>
                        </tr>
                        <tr>
                            <td><code>ClientStream&lt;T&gt;</code></td>
                            <td>Stream do cliente para servidor</td>
                        </tr>
                        <tr>
                            <td><code>BidirectionalStream&lt;T, U&gt;</code></td>
                            <td>Stream bidirecional full-duplex</td>
                        </tr>
                        <tr>
                            <td><code>StreamReceiver&lt;T&gt;</code></td>
                            <td>Receiver para leitura de stream</td>
                        </tr>
                        <tr>
                            <td><code>StreamSender&lt;T&gt;</code></td>
                            <td>Sender para escrita de stream</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Codec</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Protobuf</code></td>
                            <td>Codec Protocol Buffers otimizado</td>
                        </tr>
                        <tr>
                            <td><code>JsonCodec</code></td>
                            <td>Codec JSON (em desenvolvimento)</td>
                        </tr>
                        <tr>
                            <td><code>Codec</code></td>
                            <td>Trait para codecs customizados</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="examples" class="section fade-in">
                <h2>üí° Exemplos de Uso</h2>

                <h3>Servidor gRPC Simples</h3>
                <pre><code>use avx_grpc::{GrpcServer, Method, Request, Response};

#[derive(Clone, Message)]
struct HelloRequest {
    #[prost(string, tag = "1")]
    name: String,
}

#[derive(Clone, Message)]
struct HelloReply {
    #[prost(string, tag = "1")]
    message: String,
}

async fn say_hello(req: Request<HelloRequest>) -> Response<HelloReply> {
    let name = req.get_ref().name.clone();
    Response::new(HelloReply {
        message: format!("Hello, {}!", name),
    })
}

#[tokio::main]
async fn main() -> Result<()> {
    let server = GrpcServer::builder()
        .add_method(Method::unary("SayHello", say_hello))
        .bind("0.0.0.0:50051")
        .serve()
        .await?;

    Ok(())
}</code></pre>

                <h3>Cliente gRPC</h3>
                <pre><code>use avx_grpc::GrpcClient;

#[tokio::main]
async fn main() -> Result<()> {
    let mut client = GrpcClient::connect("http://localhost:50051").await?;

    let request = HelloRequest {
        name: "World".to_string(),
    };

    let response = client.call("SayHello", request).await?;

    println!("Response: {}", response.message);
    Ok(())
}</code></pre>

                <h3>Streaming do Servidor</h3>
                <pre><code>use avx_grpc::{GrpcServer, Method, Request, ServerStream};
use tokio::sync::mpsc;

#[derive(Clone, Message)]
struct Item {
    #[prost(int32, tag = "1")]
    id: i32,
    #[prost(string, tag = "2")]
    name: String,
}

async fn list_items(req: Request<Empty>) -> ServerStream<Item> {
    let (tx, rx) = mpsc::channel(10);

    tokio::spawn(async move {
        for i in 1..=10 {
            let item = Item {
                id: i,
                name: format!("Item {}", i),
            };
            if tx.send(item).await.is_err() {
                break;
            }
        }
    });

    ServerStream::new(rx)
}

let server = GrpcServer::builder()
    .add_method(Method::server_stream("ListItems", list_items))
    .bind("0.0.0.0:50051")
    .serve()
    .await?;</code></pre>

                <h3>Cliente com Server Stream</h3>
                <pre><code>use avx_grpc::GrpcClient;

let mut client = GrpcClient::connect("http://localhost:50051").await?;

let mut stream = client.stream::<Empty, Item>("ListItems", Empty {}).await?;

while let Some(item) = stream.next().await {
    match item {
        Ok(item) => println!("Received: {} - {}", item.id, item.name),
        Err(e) => eprintln!("Error: {}", e),
    }
}

println!("Stream completed");</code></pre>

                <h3>Streaming do Cliente</h3>
                <pre><code>use avx_grpc::{GrpcServer, Method, ClientStream, Response};

async fn upload_items(stream: ClientStream<Item>) -> Response<UploadResult> {
    let mut count = 0;

    while let Some(item) = stream.next().await {
        match item {
            Ok(item) => {
                println!("Received item: {}", item.name);
                count += 1;
            }
            Err(e) => return Response::error(Status::INTERNAL, e.to_string()),
        }
    }

    Response::new(UploadResult {
        items_received: count,
    })
}

let server = GrpcServer::builder()
    .add_method(Method::client_stream("UploadItems", upload_items))
    .bind("0.0.0.0:50051")
    .serve()
    .await?;</code></pre>

                <h3>Streaming Bidirecional</h3>
                <pre><code>use avx_grpc::{GrpcServer, Method, BidirectionalStream};

async fn chat(stream: BidirectionalStream<ChatMessage, ChatMessage>) {
    let (mut tx, mut rx) = stream.split();

    while let Some(msg) = rx.next().await {
        match msg {
            Ok(msg) => {
                println!("Received: {}", msg.text);

                // Echo back
                let response = ChatMessage {
                    text: format!("Echo: {}", msg.text),
                };

                if tx.send(response).await.is_err() {
                    break;
                }
            }
            Err(e) => {
                eprintln!("Error: {}", e);
                break;
            }
        }
    }
}

let server = GrpcServer::builder()
    .add_method(Method::bidirectional("Chat", chat))
    .bind("0.0.0.0:50051")
    .serve()
    .await?;</code></pre>

                <h3>Com Metadata e Headers</h3>
                <pre><code>use avx_grpc::{GrpcClient, Metadata};

let mut client = GrpcClient::connect("http://localhost:50051").await?;

let mut metadata = Metadata::new();
metadata.insert("authorization", "Bearer token123");
metadata.insert("x-request-id", "abc-123");

let response = client
    .call_with_metadata("SayHello", request, metadata)
    .await?;

println!("Response: {}", response.message);</code></pre>

                <h3>Interceptors (Middleware)</h3>
                <pre><code>use avx_grpc::{GrpcServer, Interceptor, Request, Response};

struct LoggingInterceptor;

impl Interceptor for LoggingInterceptor {
    async fn intercept(&self, req: Request<()>) -> Result<Request<()>> {
        println!("Request: {} {}", req.method(), req.path());
        Ok(req)
    }
}

let server = GrpcServer::builder()
    .add_interceptor(LoggingInterceptor)
    .add_method(Method::unary("SayHello", say_hello))
    .bind("0.0.0.0:50051")
    .serve()
    .await?;</code></pre>

                <h3>Timeout e Deadline</h3>
                <pre><code>use avx_grpc::GrpcClient;
use std::time::Duration;

let mut client = GrpcClient::connect("http://localhost:50051").await?;

let response = client
    .call("SayHello", request)
    .timeout(Duration::from_secs(5))
    .await?;

println!("Response: {}", response.message);</code></pre>

                <h3>Error Handling</h3>
                <pre><code>use avx_grpc::{Response, Status};

async fn get_user(req: Request<GetUserRequest>) -> Response<User> {
    let user_id = req.get_ref().id;

    match database.get_user(user_id).await {
        Ok(Some(user)) => Response::new(user),
        Ok(None) => Response::error(
            Status::NOT_FOUND,
            format!("User {} not found", user_id)
        ),
        Err(e) => Response::error(
            Status::INTERNAL,
            format!("Database error: {}", e)
        ),
    }
}</code></pre>

                <h3>Servidor Completo (Produ√ß√£o)</h3>
                <pre><code>use avx_grpc::*;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<()> {
    // Logging interceptor
    let logging = LoggingInterceptor::new();

    // Auth interceptor
    let auth = AuthInterceptor::new("secret-key");

    // Metrics interceptor
    let metrics = MetricsInterceptor::new();

    // Criar servidor
    let server = GrpcServer::builder()
        // Interceptors
        .add_interceptor(logging)
        .add_interceptor(auth)
        .add_interceptor(metrics)

        // Services
        .add_service(UserService::new())
        .add_service(ProductService::new())
        .add_service(OrderService::new())

        // Configura√ß√£o
        .max_concurrent_streams(100)
        .max_frame_size(16384)
        .keepalive_interval(Duration::from_secs(60))
        .keepalive_timeout(Duration::from_secs(20))

        // TLS
        .tls_config(TlsConfig::builder()
            .cert_path("cert.pem")
            .key_path("key.pem")
            .build())

        // Health check
        .health_check(true)

        // Reflection
        .reflection(true)

        // Bind e serve
        .bind("0.0.0.0:50051")
        .serve()
        .await?;

    Ok(())
}</code></pre>
            </section>

            <section id="api" class="section fade-in">
                <h2>üìö Refer√™ncias da API</h2>

                <h3>GrpcServer</h3>
                <div class="module-card">
                    <h4><code>GrpcServer::builder() -> GrpcServerBuilder</code></h4>
                    <p>Cria construtor de servidor gRPC.</p>
                </div>

                <div class="module-card">
                    <h4><code>GrpcServerBuilder::add_method(method: Method) -> Self</code></h4>
                    <p>Adiciona m√©todo RPC ao servidor.</p>
                </div>

                <div class="module-card">
                    <h4><code>GrpcServer::serve() -> Result&lt;()&gt;</code></h4>
                    <p>Inicia servidor e processa requisi√ß√µes gRPC.</p>
                </div>

                <h3 class="mt-3">GrpcClient</h3>
                <div class="module-card">
                    <h4><code>GrpcClient::connect(uri: &str) -> Result&lt;Self&gt;</code></h4>
                    <p>Conecta ao servidor gRPC especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>GrpcClient::call&lt;Req, Res&gt;(method: &str, req: Req) -> Result&lt;Res&gt;</code></h4>
                    <p>Executa chamada RPC un√°ria.</p>
                </div>

                <div class="module-card">
                    <h4><code>GrpcClient::stream&lt;Req, Res&gt;(method: &str, req: Req) -> Result&lt;Stream&lt;Res&gt;&gt;</code></h4>
                    <p>Inicia stream do servidor.</p>
                </div>

                <h3 class="mt-3">Method</h3>
                <div class="module-card">
                    <h4><code>Method::unary(name: &str, handler: H) -> Self</code></h4>
                    <p>Define m√©todo un√°rio (requisi√ß√£o/resposta √∫nica).</p>
                </div>

                <div class="module-card">
                    <h4><code>Method::server_stream(name: &str, handler: H) -> Self</code></h4>
                    <p>Define m√©todo com streaming do servidor.</p>
                </div>

                <div class="module-card">
                    <h4><code>Method::client_stream(name: &str, handler: H) -> Self</code></h4>
                    <p>Define m√©todo com streaming do cliente.</p>
                </div>

                <div class="module-card">
                    <h4><code>Method::bidirectional(name: &str, handler: H) -> Self</code></h4>
                    <p>Define m√©todo com streaming bidirecional.</p>
                </div>
            </section>

            <section id="performance" class="section fade-in">
                <h2>‚ö° Performance</h2>

                <div class="performance-chart">
                    <h3>Benchmarks - Throughput</h3>
                    <div class="chart-bar">
                        <div class="chart-label">Unary RPC</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="95" style="width: 0;">80k RPC/s</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Server Streaming</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="92" style="width: 0;">150k msg/s</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Client Streaming</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="90" style="width: 0;">140k msg/s</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Bidirectional</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="88" style="width: 0;">120k msg/s</div>
                        </div>
                    </div>
                </div>

                <div class="performance-chart mt-3">
                    <h3>Lat√™ncia (p99)</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Opera√ß√£o</th>
                                <th>AVX gRPC</th>
                                <th>Melhoria</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Unary RPC</td>
                                <td>1.8 ms</td>
                                <td>3.5x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Server Streaming</td>
                                <td>950 Œºs</td>
                                <td>4.2x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Protobuf Encode</td>
                                <td>420 Œºs</td>
                                <td>5.8x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Protobuf Decode</td>
                                <td>380 Œºs</td>
                                <td>6.1x mais r√°pido</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="mt-3">Caracter√≠sticas de Performance</h3>
                <div class="modules-grid">
                    <div class="module-card">
                        <h4>‚úÖ HTTP/2 Multiplexing</h4>
                        <p>Multiplexa√ß√£o eficiente de streams HTTP/2</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Zero-Copy Streaming</h4>
                        <p>Streaming sem c√≥pias desnecess√°rias de dados</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Connection Pooling</h4>
                        <p>Pool de conex√µes inteligente no cliente</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Protobuf Otimizado</h4>
                        <p>Codifica√ß√£o Protocol Buffers ultra-r√°pida</p>
                    </div>
                </div>
            </section>

            <section id="usecases" class="section fade-in">
                <h2>üé¨ Casos de Uso</h2>

                <div class="module-card">
                    <h3>üè¢ Comunica√ß√£o entre Microservi√ßos</h3>
                    <p>Integre microservi√ßos com comunica√ß√£o eficiente e type-safe usando gRPC.</p>
                    <pre><code>// Service-to-service communication
let response = user_client
    .get_user(GetUserRequest { id: 123 })
    .await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üìä Streaming de Dados em Tempo Real</h3>
                    <p>Implemente streaming bidirecional para aplica√ß√µes real-time como chat e monitoramento.</p>
                    <pre><code>// Real-time metrics streaming
let mut stream = metrics_client
    .stream_metrics(StreamRequest {})
    .await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üöÄ APIs Internas de Alta Performance</h3>
                    <p>Construa APIs internas otimizadas para baixa lat√™ncia entre servi√ßos cr√≠ticos.</p>
                    <pre><code>// High-performance internal API
let server = GrpcServer::builder()
    .add_service(CriticalService::new())
    .serve().await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üì± Mobile Backend</h3>
                    <p>Ofere√ßa APIs eficientes para aplica√ß√µes m√≥veis com menor uso de bateria e dados.</p>
                    <pre><code>// Mobile-friendly API
let response = mobile_client
    .sync_data(SyncRequest { ... })
    .await?;</code></pre>
                </div>
            </section>

            <section id="license" class="section fade-in">
                <h2>üìÑ Licen√ßa</h2>
                <p><strong>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</strong></p>
                <p>Software Propriet√°rio - Veja <a href="../../LICENSE-PROPRIETARY.md">LICENSE-PROPRIETARY.md</a></p>
                <p class="mt-2">Para licenciamento comercial, entre em contato: <a href="mailto:nicolas@avila.inc">nicolas@avila.inc</a></p>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <p>¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</p>
                <div class="footer-links">
                    <a href="https://avila.inc">Contato</a>
                    <a href="https://docs.avila.inc">Documenta√ß√£o</a>
                    <a href="../../LICENSE-PROPRIETARY.md">Licen√ßa</a>
                </div>
            </div>
        </div>
    </footer>

    <script src="../assets/js/main.js"></script>
</body>
</html>
