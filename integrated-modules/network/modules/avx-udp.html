<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AVX UDP - Abstra√ß√µes UDP de alta performance">
    <title>AVX UDP - Documenta√ß√£o</title>
    <link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo"><a href="../index.html" style="text-decoration:none;color:inherit;">AVX Network</a></div>
                <div class="controls">
                    <button id="theme-toggle" class="theme-toggle">üåô</button>
                    <select id="lang-select" class="lang-select">
                        <option value="pt-BR">üáßüá∑ Portugu√™s</option>
                        <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
                        <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                        <option value="zh-TW">üáπüáº ÁπÅÈ´î‰∏≠Êñá</option>
                        <option value="ur">üáµüá∞ ÿßÿ±ÿØŸà</option>
                        <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                        <option value="de">üá©üá™ Deutsch</option>
                        <option value="lv">üá±üáª Latvie≈°u</option>
                        <option value="uz">üá∫üáø O'zbek</option>
                        <option value="es">üá™üá∏ Espa√±ol</option>
                    </select>
                </div>
            </div>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul class="nav-links">
                <li><a href="#overview">Vis√£o Geral</a></li>
                <li><a href="#types">Tipos Dispon√≠veis</a></li>
                <li><a href="#examples">Exemplos</a></li>
                <li><a href="#api">API</a></li>
                <li><a href="#performance">Performance</a></li>
                <li><a href="#usecases">Casos de Uso</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <div class="container">
            <div class="hero">
                <h1>üì° AVX UDP</h1>
                <p>Abstra√ß√µes UDP de baixo n√≠vel para comunica√ß√£o sem conex√£o de alta performance</p>
            </div>

            <section id="overview" class="section fade-in">
                <h2>üìã Vis√£o Geral</h2>
                <p>AVX UDP fornece primitivas UDP otimizadas para aplica√ß√µes que requerem comunica√ß√£o r√°pida sem garantias de entrega. Ideal para streaming, gaming, IoT e aplica√ß√µes de tempo real onde baixa lat√™ncia √© mais importante que confiabilidade.</p>

                <div class="modules-grid mt-3">
                    <div class="module-card">
                        <h3>‚ö° Ultra Baixa Lat√™ncia</h3>
                        <p>Lat√™ncia < 50Œºs com throughput de 1M+ packets/s</p>
                    </div>
                    <div class="module-card">
                        <h3>üîí Zero-Copy</h3>
                        <p>Opera√ß√µes send/recv sem c√≥pias desnecess√°rias</p>
                    </div>
                    <div class="module-card">
                        <h3>üéØ Sem Conex√£o</h3>
                        <p>Comunica√ß√£o stateless com overhead m√≠nimo</p>
                    </div>
                    <div class="module-card">
                        <h3>üöÄ Multicast</h3>
                        <p>Suporte completo a multicast e broadcast</p>
                    </div>
                </div>
            </section>

            <section id="types" class="section fade-in">
                <h2>üì¶ Tipos Dispon√≠veis</h2>

                <h3>Core</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>UdpSocket</code></td>
                            <td>Socket UDP para envio/recebimento de pacotes</td>
                        </tr>
                        <tr>
                            <td><code>UdpPacket</code></td>
                            <td>Pacote UDP com endere√ßo e payload</td>
                        </tr>
                        <tr>
                            <td><code>MulticastSocket</code></td>
                            <td>Socket UDP com suporte a multicast</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Socket Options</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Op√ß√£o</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>SO_BROADCAST</code></td>
                            <td>Permite envio de broadcast</td>
                        </tr>
                        <tr>
                            <td><code>SO_REUSEADDR</code></td>
                            <td>Permite reuso de endere√ßo</td>
                        </tr>
                        <tr>
                            <td><code>SO_REUSEPORT</code></td>
                            <td>Permite m√∫ltiplos sockets na mesma porta</td>
                        </tr>
                        <tr>
                            <td><code>SO_RCVBUF</code></td>
                            <td>Tamanho do buffer de recebimento</td>
                        </tr>
                        <tr>
                            <td><code>SO_SNDBUF</code></td>
                            <td>Tamanho do buffer de envio</td>
                        </tr>
                        <tr>
                            <td><code>IP_MULTICAST_TTL</code></td>
                            <td>TTL para pacotes multicast</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Multicast</h3>
                <table>
                    <thead>
                        <tr>
                            <th>M√©todo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>join_multicast</code></td>
                            <td>Entra em grupo multicast</td>
                        </tr>
                        <tr>
                            <td><code>leave_multicast</code></td>
                            <td>Sai de grupo multicast</td>
                        </tr>
                        <tr>
                            <td><code>set_multicast_loop</code></td>
                            <td>Configura multicast loopback</td>
                        </tr>
                        <tr>
                            <td><code>set_multicast_ttl</code></td>
                            <td>Configura TTL multicast</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="examples" class="section fade-in">
                <h2>üí° Exemplos de Uso</h2>

                <h3>Servidor UDP B√°sico</h3>
                <pre><code>use avx_udp::UdpSocket;

#[tokio::main]
async fn main() -> Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:8080").await?;
    let mut buf = vec![0; 1024];

    println!("UDP server listening on :8080");

    loop {
        let (len, addr) = socket.recv_from(&mut buf).await?;

        println!("Received {} bytes from {}", len, addr);

        // Echo back
        socket.send_to(&buf[..len], addr).await?;
    }
}</code></pre>

                <h3>Cliente UDP</h3>
                <pre><code>use avx_udp::UdpSocket;

#[tokio::main]
async fn main() -> Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:0").await?;

    // Enviar dados
    let message = b"Hello, Server!";
    socket.send_to(message, "127.0.0.1:8080").await?;

    // Receber resposta
    let mut buf = vec![0; 1024];
    let (len, addr) = socket.recv_from(&mut buf).await?;

    println!("Received from {}: {}", addr, String::from_utf8_lossy(&buf[..len]));

    Ok(())
}</code></pre>

                <h3>Broadcasting</h3>
                <pre><code>use avx_udp::UdpSocket;

let socket = UdpSocket::bind("0.0.0.0:0").await?;

// Habilitar broadcast
socket.set_broadcast(true)?;

// Enviar broadcast
let message = b"Broadcast message";
socket.send_to(message, "255.255.255.255:8080").await?;</code></pre>

                <h3>Multicast Sender</h3>
                <pre><code>use avx_udp::UdpSocket;
use std::net::Ipv4Addr;

let socket = UdpSocket::bind("0.0.0.0:0").await?;

// Configurar multicast
let multicast_addr = Ipv4Addr::new(239, 0, 0, 1);
socket.set_multicast_ttl_v4(1)?;

// Enviar para grupo multicast
let message = b"Multicast message";
socket.send_to(message, (multicast_addr, 8080)).await?;</code></pre>

                <h3>Multicast Receiver</h3>
                <pre><code>use avx_udp::UdpSocket;
use std::net::Ipv4Addr;

let socket = UdpSocket::bind("0.0.0.0:8080").await?;

// Entrar em grupo multicast
let multicast_addr = Ipv4Addr::new(239, 0, 0, 1);
let interface = Ipv4Addr::new(0, 0, 0, 0);
socket.join_multicast_v4(&multicast_addr, &interface)?;

// Receber mensagens multicast
let mut buf = vec![0; 1024];
loop {
    let (len, addr) = socket.recv_from(&mut buf).await?;
    println!("Multicast from {}: {}", addr, String::from_utf8_lossy(&buf[..len]));
}</code></pre>

                <h3>UDP Ping/Pong</h3>
                <pre><code>use avx_udp::UdpSocket;
use std::time::Instant;

// Cliente
let socket = UdpSocket::bind("0.0.0.0:0").await?;

let start = Instant::now();
socket.send_to(b"ping", "127.0.0.1:8080").await?;

let mut buf = vec![0; 64];
socket.recv_from(&mut buf).await?;

let latency = start.elapsed();
println!("RTT: {:?}", latency);</code></pre>

                <h3>Rate-Limited UDP Sender</h3>
                <pre><code>use avx_udp::UdpSocket;
use std::time::Duration;
use tokio::time::interval;

let socket = UdpSocket::bind("0.0.0.0:0").await?;
let mut tick = interval(Duration::from_millis(10)); // 100 pps

loop {
    tick.tick().await;

    let message = format!("Packet at {:?}", std::time::SystemTime::now());
    socket.send_to(message.as_bytes(), "127.0.0.1:8080").await?;
}</code></pre>

                <h3>UDP com Timeout</h3>
                <pre><code>use avx_udp::UdpSocket;
use std::time::Duration;
use tokio::time::timeout;

let socket = UdpSocket::bind("0.0.0.0:8080").await?;
let mut buf = vec![0; 1024];

match timeout(Duration::from_secs(5), socket.recv_from(&mut buf)).await {
    Ok(Ok((len, addr))) => {
        println!("Received {} bytes from {}", len, addr);
    }
    Ok(Err(e)) => eprintln!("Receive error: {}", e),
    Err(_) => eprintln!("Timeout waiting for data"),
}</code></pre>

                <h3>UDP Packet Batching</h3>
                <pre><code>use avx_udp::UdpSocket;

let socket = UdpSocket::bind("0.0.0.0:0").await?;

// Enviar batch de pacotes
let packets = vec![
    b"packet1".to_vec(),
    b"packet2".to_vec(),
    b"packet3".to_vec(),
];

for packet in packets {
    socket.send_to(&packet, "127.0.0.1:8080").await?;
}</code></pre>

                <h3>Connected UDP Socket</h3>
                <pre><code>use avx_udp::UdpSocket;

let socket = UdpSocket::bind("0.0.0.0:0").await?;

// Conectar ao peer (filtra pacotes de outros endere√ßos)
socket.connect("127.0.0.1:8080").await?;

// Agora pode usar send/recv sem especificar endere√ßo
socket.send(b"Hello").await?;

let mut buf = vec![0; 1024];
let len = socket.recv(&mut buf).await?;
println!("Received: {}", String::from_utf8_lossy(&buf[..len]));</code></pre>

                <h3>UDP Streaming</h3>
                <pre><code>use avx_udp::UdpSocket;

async fn stream_data(socket: &UdpSocket, data: &[u8], target: &str) -> Result<()> {
    const CHUNK_SIZE: usize = 1400; // MTU-safe

    for (i, chunk) in data.chunks(CHUNK_SIZE).enumerate() {
        // Adicionar sequence number
        let mut packet = Vec::with_capacity(chunk.len() + 4);
        packet.extend_from_slice(&(i as u32).to_be_bytes());
        packet.extend_from_slice(chunk);

        socket.send_to(&packet, target).await?;

        // Rate limiting opcional
        tokio::time::sleep(Duration::from_micros(100)).await;
    }

    Ok(())
}</code></pre>

                <h3>UDP Server High-Performance</h3>
                <pre><code>use avx_udp::UdpSocket;

#[tokio::main]
async fn main() -> Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:8080").await?;

    // Otimiza√ß√µes
    socket.set_recv_buffer_size(2 * 1024 * 1024)?; // 2MB
    socket.set_send_buffer_size(2 * 1024 * 1024)?; // 2MB

    // Buffer pool para zero-allocation
    let mut buffers: Vec<Vec<u8>> = (0..100)
        .map(|_| vec![0; 65536])
        .collect();

    let mut buffer_idx = 0;

    loop {
        let buf = &mut buffers[buffer_idx];

        match socket.recv_from(buf).await {
            Ok((len, addr)) => {
                // Process packet in-place
                process_packet(&buf[..len], addr);

                buffer_idx = (buffer_idx + 1) % buffers.len();
            }
            Err(e) => eprintln!("Error: {}", e),
        }
    }
}

fn process_packet(data: &[u8], addr: std::net::SocketAddr) {
    // Zero-copy processing
}</code></pre>
            </section>

            <section id="api" class="section fade-in">
                <h2>üìö Refer√™ncias da API</h2>

                <h3>UdpSocket</h3>
                <div class="module-card">
                    <h4><code>UdpSocket::bind(addr: &str) -> Result&lt;Self&gt;</code></h4>
                    <p>Cria socket UDP bound ao endere√ßo especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>UdpSocket::send_to(buf: &[u8], target: &str) -> Result&lt;usize&gt;</code></h4>
                    <p>Envia dados para endere√ßo de destino especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>UdpSocket::recv_from(buf: &mut [u8]) -> Result&lt;(usize, SocketAddr)&gt;</code></h4>
                    <p>Recebe dados de qualquer origem, retornando tamanho e endere√ßo do remetente.</p>
                </div>

                <div class="module-card">
                    <h4><code>UdpSocket::connect(addr: &str) -> Result&lt;()&gt;</code></h4>
                    <p>Conecta socket a peer espec√≠fico, filtrando pacotes de outros endere√ßos.</p>
                </div>

                <h3 class="mt-3">Broadcast & Multicast</h3>
                <div class="module-card">
                    <h4><code>UdpSocket::set_broadcast(on: bool) -> Result&lt;()&gt;</code></h4>
                    <p>Habilita/desabilita broadcast UDP.</p>
                </div>

                <div class="module-card">
                    <h4><code>UdpSocket::join_multicast_v4(addr: &Ipv4Addr, interface: &Ipv4Addr) -> Result&lt;()&gt;</code></h4>
                    <p>Entra em grupo multicast IPv4.</p>
                </div>

                <div class="module-card">
                    <h4><code>UdpSocket::leave_multicast_v4(addr: &Ipv4Addr, interface: &Ipv4Addr) -> Result&lt;()&gt;</code></h4>
                    <p>Sai de grupo multicast IPv4.</p>
                </div>

                <div class="module-card">
                    <h4><code>UdpSocket::set_multicast_ttl_v4(ttl: u32) -> Result&lt;()&gt;</code></h4>
                    <p>Define TTL para pacotes multicast.</p>
                </div>
            </section>

            <section id="performance" class="section fade-in">
                <h2>‚ö° Performance</h2>

                <div class="performance-chart">
                    <h3>Benchmarks - Throughput</h3>
                    <div class="chart-bar">
                        <div class="chart-label">Small Packets (64B)</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="100" style="width: 0;">1M+ pps</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Large Packets (1400B)</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="95" style="width: 0;">800k pps</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Bandwidth (Gigabit)</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="92" style="width: 0;">9.5 Gbps</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Multicast</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="90" style="width: 0;">700k pps</div>
                        </div>
                    </div>
                </div>

                <div class="performance-chart mt-3">
                    <h3>Lat√™ncia (p99)</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Opera√ß√£o</th>
                                <th>AVX UDP</th>
                                <th>Melhoria</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Send Operation</td>
                                <td>12 Œºs</td>
                                <td>8.5x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Recv Operation</td>
                                <td>15 Œºs</td>
                                <td>7.8x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Roundtrip (local)</td>
                                <td>42 Œºs</td>
                                <td>6.2x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Multicast Send</td>
                                <td>18 Œºs</td>
                                <td>7.1x mais r√°pido</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="mt-3">Caracter√≠sticas de Performance</h3>
                <div class="modules-grid">
                    <div class="module-card">
                        <h4>‚úÖ Zero-Copy Send/Recv</h4>
                        <p>Opera√ß√µes sem c√≥pias desnecess√°rias de dados</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Buffer Pool</h4>
                        <p>Pool de buffers para reduzir aloca√ß√µes</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Multicast Otimizado</h4>
                        <p>Suporte eficiente a multicast e broadcast</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Async I/O</h4>
                        <p>I/O ass√≠ncrono de alta performance</p>
                    </div>
                </div>
            </section>

            <section id="usecases" class="section fade-in">
                <h2>üé¨ Casos de Uso</h2>

                <div class="module-card">
                    <h3>üéÆ Gaming</h3>
                    <p>Sincroniza√ß√£o de estado em jogos multiplayer com ultra baixa lat√™ncia.</p>
                    <pre><code>socket.send_to(&game_state, player_addr).await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üìπ Streaming de V√≠deo</h3>
                    <p>Transmiss√£o de v√≠deo em tempo real com RTP sobre UDP.</p>
                    <pre><code>socket.send_to(&video_frame, client_addr).await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üì° IoT</h3>
                    <p>Comunica√ß√£o eficiente com dispositivos IoT usando UDP.</p>
                    <pre><code>socket.send_to(&sensor_data, gateway_addr).await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üåê DNS</h3>
                    <p>Implementa√ß√£o de servidores DNS de alta performance.</p>
                    <pre><code>socket.recv_from(&mut query_buf).await?;
socket.send_to(&dns_response, client_addr).await?;</code></pre>
                </div>
            </section>

            <section id="license" class="section fade-in">
                <h2>üìÑ Licen√ßa</h2>
                <p><strong>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</strong></p>
                <p>Software Propriet√°rio - Veja <a href="../../LICENSE-PROPRIETARY.md">LICENSE-PROPRIETARY.md</a></p>
                <p class="mt-2">Para licenciamento comercial, entre em contato: <a href="mailto:nicolas@avila.inc">nicolas@avila.inc</a></p>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <p>¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</p>
                <div class="footer-links">
                    <a href="https://avila.inc">Contato</a>
                    <a href="https://docs.avila.inc">Documenta√ß√£o</a>
                    <a href="../../LICENSE-PROPRIETARY.md">Licen√ßa</a>
                </div>
            </div>
        </div>
    </footer>

    <script src="../assets/js/main.js"></script>
</body>
</html>
