<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AVX TCP - Abstra√ß√µes TCP de alta performance">
    <title>AVX TCP - Documenta√ß√£o</title>
    <link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo"><a href="../index.html" style="text-decoration:none;color:inherit;">AVX Network</a></div>
                <div class="controls">
                    <button id="theme-toggle" class="theme-toggle">üåô</button>
                    <select id="lang-select" class="lang-select">
                        <option value="pt-BR">üáßüá∑ Portugu√™s</option>
                        <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
                        <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                        <option value="zh-TW">üáπüáº ÁπÅÈ´î‰∏≠Êñá</option>
                        <option value="ur">üáµüá∞ ÿßÿ±ÿØŸà</option>
                        <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                        <option value="de">üá©üá™ Deutsch</option>
                        <option value="lv">üá±üáª Latvie≈°u</option>
                        <option value="uz">üá∫üáø O'zbek</option>
                        <option value="es">üá™üá∏ Espa√±ol</option>
                    </select>
                </div>
            </div>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul class="nav-links">
                <li><a href="#overview">Vis√£o Geral</a></li>
                <li><a href="#types">Tipos Dispon√≠veis</a></li>
                <li><a href="#examples">Exemplos</a></li>
                <li><a href="#api">API</a></li>
                <li><a href="#performance">Performance</a></li>
                <li><a href="#usecases">Casos de Uso</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <div class="container">
            <div class="hero">
                <h1>üîå AVX TCP</h1>
                <p>Abstra√ß√µes TCP de baixo n√≠vel para comunica√ß√£o de rede de alta performance</p>
            </div>

            <section id="overview" class="section fade-in">
                <h2>üìã Vis√£o Geral</h2>
                <p>AVX TCP fornece primitivas TCP otimizadas para constru√ß√£o de servidores e clientes de rede de alta performance. Implementa√ß√£o de baixo n√≠vel com controle total sobre sockets, buffers e flags TCP, oferecendo m√°xima performance e flexibilidade.</p>

                <div class="modules-grid mt-3">
                    <div class="module-card">
                        <h3>‚ö° Zero-Copy I/O</h3>
                        <p>Opera√ß√µes de leitura/escrita sem c√≥pias desnecess√°rias de dados</p>
                    </div>
                    <div class="module-card">
                        <h3>üîí Confi√°vel</h3>
                        <p>Transmiss√£o ordenada e confi√°vel com retransmiss√£o autom√°tica</p>
                    </div>
                    <div class="module-card">
                        <h3>üéØ Controle Total</h3>
                        <p>Acesso direto a socket options e flags TCP avan√ßadas</p>
                    </div>
                    <div class="module-card">
                        <h3>üöÄ Async/Await</h3>
                        <p>API ass√≠ncrona moderna com epoll/kqueue otimizado</p>
                    </div>
                </div>
            </section>

            <section id="types" class="section fade-in">
                <h2>üì¶ Tipos Dispon√≠veis</h2>

                <h3>Core</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>TcpListener</code></td>
                            <td>Servidor TCP que aceita conex√µes</td>
                        </tr>
                        <tr>
                            <td><code>TcpStream</code></td>
                            <td>Stream de conex√£o TCP estabelecida</td>
                        </tr>
                        <tr>
                            <td><code>TcpSocket</code></td>
                            <td>Socket TCP de baixo n√≠vel</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Socket Options</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Op√ß√£o</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>TCP_NODELAY</code></td>
                            <td>Desabilita algoritmo de Nagle</td>
                        </tr>
                        <tr>
                            <td><code>SO_KEEPALIVE</code></td>
                            <td>Habilita keep-alive TCP</td>
                        </tr>
                        <tr>
                            <td><code>SO_REUSEADDR</code></td>
                            <td>Permite reuso de endere√ßo local</td>
                        </tr>
                        <tr>
                            <td><code>SO_REUSEPORT</code></td>
                            <td>Permite m√∫ltiplos sockets na mesma porta</td>
                        </tr>
                        <tr>
                            <td><code>SO_RCVBUF</code></td>
                            <td>Tamanho do buffer de recebimento</td>
                        </tr>
                        <tr>
                            <td><code>SO_SNDBUF</code></td>
                            <td>Tamanho do buffer de envio</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Traits</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Trait</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>AsyncRead</code></td>
                            <td>Leitura ass√≠ncrona de dados</td>
                        </tr>
                        <tr>
                            <td><code>AsyncWrite</code></td>
                            <td>Escrita ass√≠ncrona de dados</td>
                        </tr>
                        <tr>
                            <td><code>Split</code></td>
                            <td>Divide stream em reader e writer</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="examples" class="section fade-in">
                <h2>üí° Exemplos de Uso</h2>

                <h3>Servidor TCP B√°sico</h3>
                <pre><code>use avx_tcp::TcpListener;

#[tokio::main]
async fn main() -> Result<()> {
    let listener = TcpListener::bind("0.0.0.0:8080").await?;

    println!("Server listening on :8080");

    loop {
        let (stream, addr) = listener.accept().await?;

        tokio::spawn(async move {
            handle_connection(stream, addr).await;
        });
    }
}

async fn handle_connection(mut stream: TcpStream, addr: SocketAddr) {
    println!("New connection from: {}", addr);

    let mut buffer = vec![0; 1024];

    loop {
        match stream.read(&mut buffer).await {
            Ok(0) => break, // Connection closed
            Ok(n) => {
                // Echo back
                stream.write_all(&buffer[..n]).await.unwrap();
            }
            Err(e) => {
                eprintln!("Error: {}", e);
                break;
            }
        }
    }

    println!("Connection closed: {}", addr);
}</code></pre>

                <h3>Cliente TCP</h3>
                <pre><code>use avx_tcp::TcpStream;

#[tokio::main]
async fn main() -> Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;

    // Enviar dados
    stream.write_all(b"Hello, Server!").await?;

    // Receber resposta
    let mut buffer = vec![0; 1024];
    let n = stream.read(&mut buffer).await?;

    println!("Received: {}", String::from_utf8_lossy(&buffer[..n]));

    Ok(())
}</code></pre>

                <h3>Servidor com TCP_NODELAY</h3>
                <pre><code>use avx_tcp::{TcpListener, TcpStream};

let listener = TcpListener::bind("0.0.0.0:8080").await?;

loop {
    let (stream, _) = listener.accept().await?;

    // Desabilitar algoritmo de Nagle para baixa lat√™ncia
    stream.set_nodelay(true)?;

    tokio::spawn(handle_connection(stream));
}</code></pre>

                <h3>Cliente com Timeout</h3>
                <pre><code>use avx_tcp::TcpStream;
use std::time::Duration;
use tokio::time::timeout;

let result = timeout(
    Duration::from_secs(5),
    TcpStream::connect("127.0.0.1:8080")
).await;

match result {
    Ok(Ok(stream)) => {
        println!("Connected!");
        // Use stream
    }
    Ok(Err(e)) => eprintln!("Connection error: {}", e),
    Err(_) => eprintln!("Connection timeout"),
}</code></pre>

                <h3>Servidor com Keep-Alive</h3>
                <pre><code>use avx_tcp::{TcpListener, TcpStream};
use std::time::Duration;

let listener = TcpListener::bind("0.0.0.0:8080").await?;

loop {
    let (stream, _) = listener.accept().await?;

    // Habilitar keep-alive
    stream.set_keepalive(Some(Duration::from_secs(60)))?;

    tokio::spawn(handle_connection(stream));
}</code></pre>

                <h3>Stream Splitting (Read/Write Concorrente)</h3>
                <pre><code>use avx_tcp::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

let stream = TcpStream::connect("127.0.0.1:8080").await?;
let (mut reader, mut writer) = stream.split();

// Task de leitura
let read_task = tokio::spawn(async move {
    let mut buffer = vec![0; 1024];
    loop {
        match reader.read(&mut buffer).await {
            Ok(0) => break,
            Ok(n) => println!("Received: {:?}", &buffer[..n]),
            Err(e) => {
                eprintln!("Read error: {}", e);
                break;
            }
        }
    }
});

// Task de escrita
let write_task = tokio::spawn(async move {
    for i in 0..10 {
        let msg = format!("Message {}\n", i);
        writer.write_all(msg.as_bytes()).await.unwrap();
        tokio::time::sleep(Duration::from_secs(1)).await;
    }
});

let _ = tokio::join!(read_task, write_task);</code></pre>

                <h3>Servidor com Buffer Pool</h3>
                <pre><code>use avx_tcp::TcpListener;
use std::sync::Arc;
use tokio::sync::Mutex;

struct BufferPool {
    buffers: Vec<Vec<u8>>,
}

impl BufferPool {
    fn new(size: usize, count: usize) -> Self {
        BufferPool {
            buffers: (0..count).map(|_| vec![0; size]).collect(),
        }
    }

    fn get(&mut self) -> Vec<u8> {
        self.buffers.pop().unwrap_or_else(|| vec![0; 4096])
    }

    fn return_buffer(&mut self, buffer: Vec<u8>) {
        if self.buffers.len() < 1000 {
            self.buffers.push(buffer);
        }
    }
}

let listener = TcpListener::bind("0.0.0.0:8080").await?;
let pool = Arc::new(Mutex::new(BufferPool::new(4096, 100)));

loop {
    let (stream, _) = listener.accept().await?;
    let pool = pool.clone();

    tokio::spawn(async move {
        let mut buffer = pool.lock().await.get();

        // Use buffer...

        pool.lock().await.return_buffer(buffer);
    });
}</code></pre>

                <h3>Servidor com Shutdown Gracioso</h3>
                <pre><code>use avx_tcp::{TcpListener, TcpStream};
use tokio::signal;
use tokio::sync::broadcast;

#[tokio::main]
async fn main() -> Result<()> {
    let listener = TcpListener::bind("0.0.0.0:8080").await?;
    let (shutdown_tx, _) = broadcast::channel(1);

    tokio::spawn(async move {
        signal::ctrl_c().await.unwrap();
        println!("Shutdown signal received");
        let _ = shutdown_tx.send(());
    });

    loop {
        let mut shutdown_rx = shutdown_tx.subscribe();

        tokio::select! {
            Ok((stream, addr)) = listener.accept() => {
                let mut shutdown_rx = shutdown_tx.subscribe();
                tokio::spawn(async move {
                    tokio::select! {
                        _ = handle_connection(stream) => {},
                        _ = shutdown_rx.recv() => {
                            println!("Closing connection: {}", addr);
                        }
                    }
                });
            }
            _ = shutdown_rx.recv() => {
                println!("Server shutting down...");
                break;
            }
        }
    }

    Ok(())
}</code></pre>

                <h3>Cliente com Reconnect</h3>
                <pre><code>use avx_tcp::TcpStream;
use std::time::Duration;

async fn connect_with_retry(addr: &str, max_retries: u32) -> Result<TcpStream> {
    let mut retries = 0;

    loop {
        match TcpStream::connect(addr).await {
            Ok(stream) => return Ok(stream),
            Err(e) if retries < max_retries => {
                retries += 1;
                eprintln!("Connection attempt {} failed: {}", retries, e);

                let delay = Duration::from_secs(2u64.pow(retries.min(5)));
                tokio::time::sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

let stream = connect_with_retry("127.0.0.1:8080", 5).await?;</code></pre>

                <h3>Servidor High-Performance</h3>
                <pre><code>use avx_tcp::{TcpListener, TcpStream};

#[tokio::main]
async fn main() -> Result<()> {
    let listener = TcpListener::bind("0.0.0.0:8080").await?;

    // Configura√ß√µes de performance
    listener.set_reuseaddr(true)?;
    listener.set_reuseport(true)?;

    loop {
        let (mut stream, _) = listener.accept().await?;

        // Otimiza√ß√µes TCP
        stream.set_nodelay(true)?;
        stream.set_send_buffer_size(256 * 1024)?;
        stream.set_recv_buffer_size(256 * 1024)?;

        tokio::spawn(async move {
            // Processar com zero-copy quando poss√≠vel
            let mut buffer = vec![0; 65536];

            loop {
                match stream.read(&mut buffer).await {
                    Ok(0) => break,
                    Ok(n) => {
                        // Process data in-place
                        process_data(&mut buffer[..n]);

                        // Send response
                        stream.write_all(&buffer[..n]).await.unwrap();
                    }
                    Err(_) => break,
                }
            }
        });
    }
}

fn process_data(data: &mut [u8]) {
    // Process data in-place (zero-copy)
}</code></pre>
            </section>

            <section id="api" class="section fade-in">
                <h2>üìö Refer√™ncias da API</h2>

                <h3>TcpListener</h3>
                <div class="module-card">
                    <h4><code>TcpListener::bind(addr: &str) -> Result&lt;Self&gt;</code></h4>
                    <p>Cria listener TCP no endere√ßo especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpListener::accept() -> Result&lt;(TcpStream, SocketAddr)&gt;</code></h4>
                    <p>Aceita nova conex√£o TCP e retorna stream e endere√ßo do cliente.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpListener::local_addr() -> Result&lt;SocketAddr&gt;</code></h4>
                    <p>Retorna endere√ßo local do listener.</p>
                </div>

                <h3 class="mt-3">TcpStream</h3>
                <div class="module-card">
                    <h4><code>TcpStream::connect(addr: &str) -> Result&lt;Self&gt;</code></h4>
                    <p>Conecta ao servidor TCP especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpStream::read(buf: &mut [u8]) -> Result&lt;usize&gt;</code></h4>
                    <p>L√™ dados do stream para o buffer.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpStream::write_all(buf: &[u8]) -> Result&lt;()&gt;</code></h4>
                    <p>Escreve todos os dados do buffer no stream.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpStream::set_nodelay(nodelay: bool) -> Result&lt;()&gt;</code></h4>
                    <p>Configura TCP_NODELAY (desabilita algoritmo de Nagle).</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpStream::set_keepalive(duration: Option&lt;Duration&gt;) -> Result&lt;()&gt;</code></h4>
                    <p>Configura TCP keep-alive com intervalo especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpStream::split() -> (ReadHalf, WriteHalf)</code></h4>
                    <p>Divide stream em halves de leitura e escrita para uso concorrente.</p>
                </div>
            </section>

            <section id="performance" class="section fade-in">
                <h2>‚ö° Performance</h2>

                <div class="performance-chart">
                    <h3>Benchmarks - Throughput</h3>
                    <div class="chart-bar">
                        <div class="chart-label">Single Connection</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="98" style="width: 0;">8 GB/s</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Concurrent Connections</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="95" style="width: 0;">100k conn/s</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Small Messages</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="92" style="width: 0;">2M msg/s</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">With TCP_NODELAY</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="93" style="width: 0;">2.5M msg/s</div>
                        </div>
                    </div>
                </div>

                <div class="performance-chart mt-3">
                    <h3>Lat√™ncia (p99)</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Opera√ß√£o</th>
                                <th>AVX TCP</th>
                                <th>Melhoria</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Connection Establishment</td>
                                <td>120 Œºs</td>
                                <td>4.8x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Read Operation</td>
                                <td>8 Œºs</td>
                                <td>7.2x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Write Operation</td>
                                <td>6 Œºs</td>
                                <td>8.1x mais r√°pido</td>
                            </tr>
                            <tr>
                                <td>Roundtrip (local)</td>
                                <td>28 Œºs</td>
                                <td>5.5x mais r√°pido</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="mt-3">Caracter√≠sticas de Performance</h3>
                <div class="modules-grid">
                    <div class="module-card">
                        <h4>‚úÖ Zero-Copy I/O</h4>
                        <p>Opera√ß√µes sem c√≥pias desnecess√°rias de dados</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Async com epoll/kqueue</h4>
                        <p>I/O ass√≠ncrono usando primitivas do sistema operacional</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ TCP_NODELAY</h4>
                        <p>Baixa lat√™ncia desabilitando algoritmo de Nagle</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Buffer Pool</h4>
                        <p>Pool de buffers otimizado para reduzir aloca√ß√µes</p>
                    </div>
                </div>
            </section>

            <section id="usecases" class="section fade-in">
                <h2>üé¨ Casos de Uso</h2>

                <div class="module-card">
                    <h3>üîß Servidores de Rede Custom</h3>
                    <p>Construa protocolos TCP customizados de alto desempenho.</p>
                    <pre><code>let listener = TcpListener::bind(":8080").await?;
// Implemente protocolo customizado</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üîÄ Proxy TCP</h3>
                    <p>Implemente proxies TCP de alto desempenho com forwarding otimizado.</p>
                    <pre><code>// Forward data entre cliente e backend
tokio::io::copy_bidirectional(&mut client, &mut backend).await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üìä Streaming de Dados</h3>
                    <p>Transmita grandes volumes de dados com performance m√°xima.</p>
                    <pre><code>// Stream large datasets
stream.write_all(&data_chunk).await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üéÆ Gaming Servers</h3>
                    <p>Servidores de jogo com baixa lat√™ncia usando TCP_NODELAY.</p>
                    <pre><code>stream.set_nodelay(true)?;
// Baixa lat√™ncia para game state updates</code></pre>
                </div>
            </section>

            <section id="license" class="section fade-in">
                <h2>üìÑ Licen√ßa</h2>
                <p><strong>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</strong></p>
                <p>Software Propriet√°rio - Veja <a href="../../LICENSE-PROPRIETARY.md">LICENSE-PROPRIETARY.md</a></p>
                <p class="mt-2">Para licenciamento comercial, entre em contato: <a href="mailto:nicolas@avila.inc">nicolas@avila.inc</a></p>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <p>¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</p>
                <div class="footer-links">
                    <a href="https://avila.inc">Contato</a>
                    <a href="https://docs.avila.inc">Documenta√ß√£o</a>
                    <a href="../../LICENSE-PROPRIETARY.md">Licen√ßa</a>
                </div>
            </div>
        </div>
    </footer>

    <script src="../assets/js/main.js"></script>
</body>
</html>
