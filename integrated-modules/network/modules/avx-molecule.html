<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AVX Molecule - Abstra√ß√µes de rede de alto n√≠vel">
    <title>AVX Molecule - Documenta√ß√£o</title>
    <link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo"><a href="../index.html" style="text-decoration:none;color:inherit;">AVX Network</a></div>
                <div class="controls">
                    <button id="theme-toggle" class="theme-toggle">üåô</button>
                    <select id="lang-select" class="lang-select">
                        <option value="pt-BR">üáßüá∑ Portugu√™s</option>
                        <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
                        <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                        <option value="zh-TW">üáπüáº ÁπÅÈ´î‰∏≠Êñá</option>
                        <option value="ur">üáµüá∞ ÿßÿ±ÿØŸà</option>
                        <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                        <option value="de">üá©üá™ Deutsch</option>
                        <option value="lv">üá±üáª Latvie≈°u</option>
                        <option value="uz">üá∫üáø O'zbek</option>
                        <option value="es">üá™üá∏ Espa√±ol</option>
                    </select>
                </div>
            </div>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul class="nav-links">
                <li><a href="#overview">Vis√£o Geral</a></li>
                <li><a href="#types">Tipos Dispon√≠veis</a></li>
                <li><a href="#examples">Exemplos</a></li>
                <li><a href="#api">API</a></li>
                <li><a href="#performance">Performance</a></li>
                <li><a href="#usecases">Casos de Uso</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <div class="container">
            <div class="hero">
                <h1>üß¨ AVX Molecule</h1>
                <p>Abstra√ß√µes de rede de alto n√≠vel para desenvolvimento r√°pido e produtivo</p>
            </div>

            <section id="overview" class="section fade-in">
                <h2>üìã Vis√£o Geral</h2>
                <p>AVX Molecule fornece APIs de alto n√≠vel para networking, abstraindo a complexidade dos protocolos TCP, UDP e TLS. Ideal para desenvolvimento r√°pido de aplica√ß√µes networked sem sacrificar performance. Molecule combina facilidade de uso com otimiza√ß√µes de baixo n√≠vel.</p>

                <div class="modules-grid mt-3">
                    <div class="module-card">
                        <h3>üöÄ High-Level APIs</h3>
                        <p>APIs simples e intuitivas para tarefas comuns</p>
                    </div>
                    <div class="module-card">
                        <h3>‚ö° Performance</h3>
                        <p>Otimiza√ß√µes autom√°ticas de baixo n√≠vel</p>
                    </div>
                    <div class="module-card">
                        <h3>üîí Secure by Default</h3>
                        <p>TLS habilitado por padr√£o com configura√ß√£o m√≠nima</p>
                    </div>
                    <div class="module-card">
                        <h3>üéØ Ergonomic</h3>
                        <p>Design ergon√¥mico para produtividade m√°xima</p>
                    </div>
                </div>
            </section>

            <section id="types" class="section fade-in">
                <h2>üì¶ Tipos Dispon√≠veis</h2>

                <h3>Core</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>TcpServer</code></td>
                            <td>Servidor TCP de alto n√≠vel com suporte a TLS</td>
                        </tr>
                        <tr>
                            <td><code>TcpClient</code></td>
                            <td>Cliente TCP simplificado com TLS opcional</td>
                        </tr>
                        <tr>
                            <td><code>UdpServer</code></td>
                            <td>Servidor UDP com buffer management autom√°tico</td>
                        </tr>
                        <tr>
                            <td><code>UdpClient</code></td>
                            <td>Cliente UDP simplificado</td>
                        </tr>
                        <tr>
                            <td><code>SecureStream</code></td>
                            <td>Stream com TLS transparente</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Configuration</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ServerConfig</code></td>
                            <td>Configura√ß√£o de servidor com defaults sensatos</td>
                        </tr>
                        <tr>
                            <td><code>ClientConfig</code></td>
                            <td>Configura√ß√£o de cliente com retry autom√°tico</td>
                        </tr>
                        <tr>
                            <td><code>TlsConfig</code></td>
                            <td>Configura√ß√£o TLS simplificada</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Protocol Helpers</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Helper</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Framed</code></td>
                            <td>Framing autom√°tico de mensagens</td>
                        </tr>
                        <tr>
                            <td><code>JsonCodec</code></td>
                            <td>Codec JSON para serializa√ß√£o autom√°tica</td>
                        </tr>
                        <tr>
                            <td><code>LineCodec</code></td>
                            <td>Codec baseado em linhas (newline-delimited)</td>
                        </tr>
                        <tr>
                            <td><code>LengthDelimited</code></td>
                            <td>Codec com prefixo de tamanho</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-3">Utilities</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Utility</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ConnectionPool</code></td>
                            <td>Pool de conex√µes reutiliz√°veis</td>
                        </tr>
                        <tr>
                            <td><code>Retry</code></td>
                            <td>Retry autom√°tico com backoff</td>
                        </tr>
                        <tr>
                            <td><code>Timeout</code></td>
                            <td>Timeouts configur√°veis</td>
                        </tr>
                        <tr>
                            <td><code>RateLimiter</code></td>
                            <td>Rate limiting integrado</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="examples" class="section fade-in">
                <h2>üí° Exemplos de Uso</h2>

                <h3>TCP Server Simples</h3>
                <pre><code>use avx_molecule::TcpServer;

#[tokio::main]
async fn main() -> Result<()> {
    let server = TcpServer::bind("0.0.0.0:8080").await?;

    println!("Server listening on :8080");

    while let Some(mut stream) = server.accept().await? {
        tokio::spawn(async move {
            let mut buf = vec![0; 1024];

            loop {
                match stream.read(&mut buf).await {
                    Ok(0) => break,
                    Ok(n) => {
                        stream.write_all(&buf[..n]).await?;
                    }
                    Err(e) => {
                        eprintln!("Error: {}", e);
                        break;
                    }
                }
            }

            Ok::<_, Box<dyn std::error::Error>>(())
        });
    }

    Ok(())
}</code></pre>

                <h3>TCP Client</h3>
                <pre><code>use avx_molecule::TcpClient;

#[tokio::main]
async fn main() -> Result<()> {
    let mut client = TcpClient::connect("127.0.0.1:8080").await?;

    client.write_all(b"Hello, Server!").await?;

    let mut buf = vec![0; 1024];
    let n = client.read(&mut buf).await?;

    println!("Response: {}", String::from_utf8_lossy(&buf[..n]));

    Ok(())
}</code></pre>

                <h3>Secure TCP Server (TLS)</h3>
                <pre><code>use avx_molecule::{TcpServer, TlsConfig};

#[tokio::main]
async fn main() -> Result<()> {
    let tls_config = TlsConfig::from_pem_files(
        "server.crt",
        "server.key"
    )?;

    let server = TcpServer::bind("0.0.0.0:8443")
        .with_tls(tls_config)
        .start()
        .await?;

    while let Some(mut stream) = server.accept().await? {
        // Stream j√° est√° com TLS estabelecido
        tokio::spawn(async move {
            handle_secure_client(stream).await
        });
    }

    Ok(())
}</code></pre>

                <h3>Framed Communication</h3>
                <pre><code>use avx_molecule::{TcpServer, Framed, LengthDelimited};

#[tokio::main]
async fn main() -> Result<()> {
    let server = TcpServer::bind("0.0.0.0:8080").await?;

    while let Some(stream) = server.accept().await? {
        tokio::spawn(async move {
            // Usar framing autom√°tico
            let mut framed = Framed::new(stream, LengthDelimited::new());

            while let Some(frame) = framed.next().await {
                match frame {
                    Ok(data) => {
                        println!("Received frame: {:?}", data);
                        framed.send(&data).await?;
                    }
                    Err(e) => eprintln!("Frame error: {}", e),
                }
            }

            Ok::<_, Box<dyn std::error::Error>>(())
        });
    }

    Ok(())
}</code></pre>

                <h3>JSON RPC over TCP</h3>
                <pre><code>use avx_molecule::{TcpServer, Framed, JsonCodec};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Request {
    method: String,
    params: Vec<i32>,
}

#[derive(Serialize, Deserialize)]
struct Response {
    result: i32,
}

#[tokio::main]
async fn main() -> Result<()> {
    let server = TcpServer::bind("0.0.0.0:8080").await?;

    while let Some(stream) = server.accept().await? {
        tokio::spawn(async move {
            let mut framed = Framed::new(stream, JsonCodec::<Request, Response>::new());

            while let Some(request) = framed.next().await {
                match request {
                    Ok(req) => {
                        let result = req.params.iter().sum();
                        let response = Response { result };
                        framed.send(&response).await?;
                    }
                    Err(e) => eprintln!("JSON error: {}", e),
                }
            }

            Ok::<_, Box<dyn std::error::Error>>(())
        });
    }

    Ok(())
}</code></pre>

                <h3>UDP Server</h3>
                <pre><code>use avx_molecule::UdpServer;

#[tokio::main]
async fn main() -> Result<()> {
    let mut server = UdpServer::bind("0.0.0.0:8080").await?;

    loop {
        let (data, addr) = server.recv().await?;

        println!("Received from {}: {:?}", addr, data);

        // Echo back
        server.send(&data, addr).await?;
    }
}</code></pre>

                <h3>Connection Pool</h3>
                <pre><code>use avx_molecule::{TcpClient, ConnectionPool};

#[tokio::main]
async fn main() -> Result<()> {
    let pool = ConnectionPool::builder()
        .max_connections(10)
        .connect_to("127.0.0.1:8080")
        .build()
        .await?;

    // Obter conex√£o do pool
    let mut conn = pool.get().await?;

    conn.write_all(b"Request").await?;

    let mut buf = vec![0; 1024];
    let n = conn.read(&mut buf).await?;

    // Conex√£o √© retornada ao pool automaticamente quando dropped
    Ok(())
}</code></pre>

                <h3>Client com Retry</h3>
                <pre><code>use avx_molecule::{TcpClient, Retry};
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<()> {
    let retry = Retry::builder()
        .max_attempts(3)
        .backoff(Duration::from_secs(1))
        .build();

    let mut client = retry
        .execute(|| TcpClient::connect("127.0.0.1:8080"))
        .await?;

    client.write_all(b"Request").await?;

    Ok(())
}</code></pre>

                <h3>Rate Limiting</h3>
                <pre><code>use avx_molecule::{TcpServer, RateLimiter};

#[tokio::main]
async fn main() -> Result<()> {
    let server = TcpServer::bind("0.0.0.0:8080").await?;
    let limiter = RateLimiter::new(100); // 100 requests/second

    while let Some(mut stream) = server.accept().await? {
        let limiter = limiter.clone();

        tokio::spawn(async move {
            // Aguardar permiss√£o do rate limiter
            limiter.acquire().await;

            handle_client(stream).await
        });
    }

    Ok(())
}</code></pre>

                <h3>Line-based Protocol</h3>
                <pre><code>use avx_molecule::{TcpServer, Framed, LineCodec};

#[tokio::main]
async fn main() -> Result<()> {
    let server = TcpServer::bind("0.0.0.0:8080").await?;

    while let Some(stream) = server.accept().await? {
        tokio::spawn(async move {
            let mut framed = Framed::new(stream, LineCodec::new());

            while let Some(line) = framed.next().await {
                match line {
                    Ok(text) => {
                        println!("Line: {}", text);
                        framed.send(&format!("Echo: {}", text)).await?;
                    }
                    Err(e) => eprintln!("Error: {}", e),
                }
            }

            Ok::<_, Box<dyn std::error::Error>>(())
        });
    }

    Ok(())
}</code></pre>

                <h3>Broadcast Server</h3>
                <pre><code>use avx_molecule::TcpServer;
use tokio::sync::broadcast;

#[tokio::main]
async fn main() -> Result<()> {
    let server = TcpServer::bind("0.0.0.0:8080").await?;
    let (tx, _) = broadcast::channel(100);

    while let Some(mut stream) = server.accept().await? {
        let mut rx = tx.subscribe();
        let tx = tx.clone();

        tokio::spawn(async move {
            let (mut reader, mut writer) = stream.split();

            // Task para broadcast
            let broadcast_task = tokio::spawn(async move {
                while let Ok(msg) = rx.recv().await {
                    writer.write_all(&msg).await?;
                }
                Ok::<_, Box<dyn std::error::Error>>(())
            });

            // Task para receber mensagens
            let mut buf = vec![0; 1024];
            loop {
                match reader.read(&mut buf).await {
                    Ok(0) => break,
                    Ok(n) => {
                        tx.send(buf[..n].to_vec())?;
                    }
                    Err(_) => break,
                }
            }

            broadcast_task.abort();
            Ok::<_, Box<dyn std::error::Error>>(())
        });
    }

    Ok(())
}</code></pre>

                <h3>HTTP Client Simples</h3>
                <pre><code>use avx_molecule::{TcpClient, TlsConfig};

async fn http_get(url: &str) -> Result<String> {
    let tls_config = TlsConfig::default();

    let mut client = TcpClient::connect("example.com:443")
        .with_tls(tls_config, "example.com")
        .await?;

    let request = format!(
        "GET {} HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n",
        url
    );

    client.write_all(request.as_bytes()).await?;

    let mut response = String::new();
    client.read_to_string(&mut response).await?;

    Ok(response)
}</code></pre>

                <h3>Configuration Builder</h3>
                <pre><code>use avx_molecule::{TcpServer, ServerConfig};
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<()> {
    let config = ServerConfig::builder()
        .bind_address("0.0.0.0:8080")
        .max_connections(1000)
        .read_timeout(Duration::from_secs(30))
        .write_timeout(Duration::from_secs(30))
        .nodelay(true)
        .keepalive(Some(Duration::from_secs(60)))
        .build();

    let server = TcpServer::with_config(config).await?;

    // ... handle connections

    Ok(())
}</code></pre>
            </section>

            <section id="api" class="section fade-in">
                <h2>üìö Refer√™ncias da API</h2>

                <h3>TcpServer</h3>
                <div class="module-card">
                    <h4><code>TcpServer::bind(addr: &str) -> Result&lt;Self&gt;</code></h4>
                    <p>Cria servidor TCP bound ao endere√ßo especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpServer::accept() -> Result&lt;Stream&gt;</code></h4>
                    <p>Aceita nova conex√£o de cliente.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpServer::with_tls(config: TlsConfig) -> Builder</code></h4>
                    <p>Adiciona suporte TLS ao servidor.</p>
                </div>

                <h3 class="mt-3">TcpClient</h3>
                <div class="module-card">
                    <h4><code>TcpClient::connect(addr: &str) -> Result&lt;Self&gt;</code></h4>
                    <p>Conecta ao servidor TCP especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>TcpClient::with_tls(config: TlsConfig, domain: &str) -> Result&lt;Self&gt;</code></h4>
                    <p>Estabelece conex√£o TLS com servidor.</p>
                </div>

                <h3 class="mt-3">Framed</h3>
                <div class="module-card">
                    <h4><code>Framed::new(stream: Stream, codec: Codec) -> Self</code></h4>
                    <p>Cria stream com framing usando codec especificado.</p>
                </div>

                <div class="module-card">
                    <h4><code>Framed::send(data: &T) -> Result&lt;()&gt;</code></h4>
                    <p>Envia dado serializado com framing.</p>
                </div>

                <div class="module-card">
                    <h4><code>Framed::next() -> Option&lt;Result&lt;T&gt;&gt;</code></h4>
                    <p>Recebe pr√≥ximo frame deserializado.</p>
                </div>

                <h3 class="mt-3">ConnectionPool</h3>
                <div class="module-card">
                    <h4><code>ConnectionPool::builder() -> Builder</code></h4>
                    <p>Inicia builder de connection pool.</p>
                </div>

                <div class="module-card">
                    <h4><code>ConnectionPool::get() -> Result&lt;Connection&gt;</code></h4>
                    <p>Obt√©m conex√£o do pool (reutiliza ou cria nova).</p>
                </div>
            </section>

            <section id="performance" class="section fade-in">
                <h2>‚ö° Performance</h2>

                <div class="performance-chart">
                    <h3>Benchmarks - Overhead vs Raw TCP</h3>
                    <div class="chart-bar">
                        <div class="chart-label">TCP Plain</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="95" style="width: 0;">< 5% overhead</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">TLS (Hardware AES)</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="88" style="width: 0;">< 12% overhead</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">Framed (LengthDelimited)</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="92" style="width: 0;">< 8% overhead</div>
                        </div>
                    </div>
                    <div class="chart-bar">
                        <div class="chart-label">JSON Codec</div>
                        <div class="chart-track">
                            <div class="chart-fill" data-value="75" style="width: 0;">Depende payload</div>
                        </div>
                    </div>
                </div>

                <div class="performance-chart mt-3">
                    <h3>Connection Pool Performance</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>M√©trica</th>
                                <th>Sem Pool</th>
                                <th>Com Pool</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Connection Time</td>
                                <td>2.5 ms</td>
                                <td>45 Œºs (55x mais r√°pido)</td>
                            </tr>
                            <tr>
                                <td>Requests/sec (single thread)</td>
                                <td>400</td>
                                <td>22,000</td>
                            </tr>
                            <tr>
                                <td>Latency (p99)</td>
                                <td>8 ms</td>
                                <td>320 Œºs</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="mt-3">Caracter√≠sticas de Performance</h3>
                <div class="modules-grid">
                    <div class="module-card">
                        <h4>‚úÖ Zero-Cost Abstractions</h4>
                        <p>APIs de alto n√≠vel sem overhead significativo</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Connection Pooling</h4>
                        <p>Reuso de conex√µes para m√°xima performance</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Async I/O</h4>
                        <p>I/O ass√≠ncrono nativo para escalabilidade</p>
                    </div>
                    <div class="module-card">
                        <h4>‚úÖ Smart Defaults</h4>
                        <p>Configura√ß√µes otimizadas por padr√£o</p>
                    </div>
                </div>
            </section>

            <section id="usecases" class="section fade-in">
                <h2>üé¨ Casos de Uso</h2>

                <div class="module-card">
                    <h3>üöÄ Prototipagem R√°pida</h3>
                    <p>Desenvolvimento r√°pido de prot√≥tipos networked.</p>
                    <pre><code>let server = TcpServer::bind("0.0.0.0:8080").await?;
while let Some(stream) = server.accept().await? { ... }</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üîê Microservices</h3>
                    <p>Comunica√ß√£o segura entre microservices com TLS.</p>
                    <pre><code>let client = TcpClient::connect("service:8080")
    .with_tls(tls_config, "service")
    .await?;</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üì° Chat Server</h3>
                    <p>Servidor de chat com broadcast integrado.</p>
                    <pre><code>let (tx, _) = broadcast::channel(100);
// ... broadcast messages to all clients</code></pre>
                </div>

                <div class="module-card mt-3">
                    <h3>üéÆ Game Backend</h3>
                    <p>Backend de jogo com JSON-RPC e connection pooling.</p>
                    <pre><code>let pool = ConnectionPool::builder()
    .connect_to("game-db:5432")
    .build().await?;</code></pre>
                </div>
            </section>

            <section id="license" class="section fade-in">
                <h2>üìÑ Licen√ßa</h2>
                <p><strong>Copyright ¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</strong></p>
                <p>Software Propriet√°rio - Veja <a href="../../LICENSE-PROPRIETARY.md">LICENSE-PROPRIETARY.md</a></p>
                <p class="mt-2">Para licenciamento comercial, entre em contato: <a href="mailto:nicolas@avila.inc">nicolas@avila.inc</a></p>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <p>¬© 2025 N√≠colas √Åvila - Todos os Direitos Reservados</p>
                <div class="footer-links">
                    <a href="https://avila.inc">Contato</a>
                    <a href="https://docs.avila.inc">Documenta√ß√£o</a>
                    <a href="../../LICENSE-PROPRIETARY.md">Licen√ßa</a>
                </div>
            </div>
        </div>
    </footer>

    <script src="../assets/js/main.js"></script>
</body>
</html>
